MODULE NURBS_BASIS

	USE GLBVAR
	USE PATCH_MAPPING

	IMPLICIT INTEGER (I-N)
	IMPLICIT REAL(8) (A-H,O-Z)

CONTAINS

!!  GET BASIS FUNCTION ON PHYSICAL SPACE


!!  FIND DERIVATIVES OF NURBS SURFACE ON TWO-DIMENSIONAL SPACE
!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
!!  OUTPUT : DERIVATIVES OF NURBS SURFACE
SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D(SF, INDX, REF_PT, JACOB, PATCH, INV)

	INTEGER, INTENT(IN) :: PATCH
	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB
	CHARACTER(LEN=3), OPTIONAL, INTENT(IN) :: INV

	TYPE(MATRIX_22) :: INV_JACOB, JACOBIAN
	TYPE(FUNCTION_2D) :: DIFF_NURBS
	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX

	DIFF_ORDER = 1

	IF (PRESENT(INV)) THEN
		IF (INV.EQ.'INV') THEN
			INV_JACOB = JACOB
		ELSE
			INV_JACOB = .INVERSE.JACOB					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)
		ENDIF
	ELSE
		INV_JACOB = .INVERSE.JACOB
	ENDIF

! 	ELSE
! 		JACOBIAN = GET_JACOBIAN_MATRIX(REF_PT,PATCH)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
! 		INV_JACOB = .INVERSE.JACOBIAN					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)
! 	ENDIF
	
	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(PATCH,1),DIFF_ORDER)
	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(PATCH,2),DIFF_ORDER)

	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
		DWSUM(K,L) = 0.0D0
		DO J1 = 0, BASIS_KVEC(PATCH,1)%POLY_ORDER
			INDX_X = DBSFUN(1)%INIT + J1
			IF (INDX_X>=0) THEN
				DO J2 = 0, BASIS_KVEC(PATCH,2)%POLY_ORDER
					INDX_Y = DBSFUN(2)%INIT + J2
					IF (INDX_Y>=0) THEN
						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*IGA_CTL(PATCH)%WGTS(INDX_X,INDX_Y,0)
					ENDIF
				ENDDO
			ENDIF
		ENDDO
	ENDDO
	ENDDO

	LC_INDX = 0
	
	DO I1 = 0, BASIS_KVEC(PATCH,1)%POLY_ORDER
		
		INDX_X = DBSFUN(1)%INIT + I1

	DO I2 = 0, BASIS_KVEC(PATCH,2)%POLY_ORDER
		
		INDX_Y = DBSFUN(2)%INIT + I2
		LC_INDX = LC_INDX + 1
		INDX(LC_INDX) = INT2D(INDX_X, INDX_Y)
		
		DO K = 0, DIFF_ORDER
		DO L = 0, DIFF_ORDER-K
		
			DIFF_NURBS%VAL(K,L) = DBSFUN(1)%N(I1,K)*DBSFUN(2)%N(I2,L)*IGA_CTL(PATCH)%WGTS(INDX_X,INDX_Y,0)
			
			DO J1 = 1, K
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
			ENDDO
			DO J2 = 1, L
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
			ENDDO
			DO J1 = 1, K
			DO J2 = 1, L
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
			ENDDO
			ENDDO
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)
		ENDDO
		ENDDO
		
		SF(LC_INDX)%D00 = DIFF_NURBS%VAL(0,0)
		SF(LC_INDX)%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
		SF(LC_INDX)%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
		
	ENDDO
	ENDDO

END SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D

TYPE(FVALUE) FUNCTION GET_PHY_NURBS_SURFACE_2D(REF_PT, IX, IY, JACOB, PATCH)

	INTEGER, INTENT(IN) :: IX, IY, PATCH
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB

	TYPE(MATRIX_22) :: INV_JACOB
	TYPE(FUNCTION_2D) :: REF_SF, DIFF_NURBS
	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX

	DIFF_ORDER = 1

	INV_JACOB = .INVERSE.JACOB
	
	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(PATCH,1),DIFF_ORDER)
	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(PATCH,2),DIFF_ORDER)

	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
		DWSUM(K,L) = 0.0D0
		DO J1 = 0, BASIS_KVEC(PATCH,1)%POLY_ORDER
			INDX_X = DBSFUN(1)%INIT + J1
			IF (INDX_X>=0) THEN
				DO J2 = 0, BASIS_KVEC(PATCH,2)%POLY_ORDER
					INDX_Y = DBSFUN(2)%INIT + J2
					IF (INDX_Y>=0) THEN
						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*IGA_CTL(PATCH)%WGTS(INDX_X,INDX_Y,0)
					ENDIF
				ENDDO
			ENDIF
		ENDDO
	ENDDO
	ENDDO

	REF_SF = GET_BASIS(REF_PT,(/IX,IY/), PATCH)
		
	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
	
		DIFF_NURBS%VAL(K,L) = REF_SF%VAL(K,L)*IGA_CTL(PATCH)%WGTS(IX,IY,0)
		
		DO J1 = 1, K
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
		ENDDO
		DO J2 = 1, L
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
		ENDDO
		DO J1 = 1, K
		DO J2 = 1, L
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
		ENDDO
		ENDDO

		DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)

	ENDDO
	ENDDO
	
	GET_PHY_NURBS_SURFACE_2D%D00 = DIFF_NURBS%VAL(0,0)
	GET_PHY_NURBS_SURFACE_2D%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
	GET_PHY_NURBS_SURFACE_2D%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
		
END FUNCTION GET_PHY_NURBS_SURFACE_2D

TYPE(FVALUE) FUNCTION GET_PHY_BASIS_IN_INT(REF_PT, IX, IY, JACOB, PATCH)

	TYPE(POINT2D), INTENT(IN) :: REF_PT
	INTEGER, INTENT(IN) :: IX, IY, PATCH
	TYPE(MATRIX_22), INTENT(IN) :: JACOB

	TYPE(MATRIX_22) :: INV_JACOB
	TYPE(SECOND_PARTIAL_DERIVATIVES) :: SECOND_PD
	REAL(8) :: J, JXI, JETA, S(2,3)
	TYPE(FUNCTION_2D) :: REF_SF

	INV_JACOB = .INVERSE.JACOB					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)

	REF_SF = GET_BASIS(REF_PT,(/IX,IY/), PATCH)

	GET_PHY_BASIS_IN_INT%D00 = REF_SF%VAL(0,0)
	GET_PHY_BASIS_IN_INT%D10 = REF_SF%VAL(1,0)*INV_JACOB%ENT(1,1) + REF_SF%VAL(0,1)*INV_JACOB%ENT(2,1)
	GET_PHY_BASIS_IN_INT%D01 = REF_SF%VAL(1,0)*INV_JACOB%ENT(1,2) + REF_SF%VAL(0,1)*INV_JACOB%ENT(2,2)

END FUNCTION GET_PHY_BASIS_IN_INT

TYPE(FVALUE) FUNCTION GET_PHY_BASIS(REF_PT,IX,IY, PATCH)

	TYPE(POINT2D), INTENT(IN) :: REF_PT
	INTEGER, INTENT(IN) :: IX, IY, PATCH

	TYPE(MATRIX_22) :: JACOB, INV_JACOB
	TYPE(SECOND_PARTIAL_DERIVATIVES) :: SECOND_PD
	REAL(8) :: J, JXI, JETA, S(2,3)
	TYPE(FUNCTION_2D) :: REF_SF

	JACOB = GET_JACOBIAN_MATRIX(REF_PT, PATCH)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
	INV_JACOB = .INVERSE.JACOB					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)

! 	SECOND_PD = GET_PARTIAL(REF_PT)				!! P^2(X)/P(XI^2), P^2(X)/P(XI,ETA), P^2(X)/P(ETA^2), P^2(Y)/P(XI^2), P^2(Y)/P(XI,ETA), P^2(Y)/P(ETA^2)
! 
!  	J = JACOB%ENT(1,1)*JACOB%ENT(2,2)-JACOB%ENT(1,2)*JACOB%ENT(2,1)
! 	JXI = SECOND_PD%X(1)*JACOB%ENT(2,2)+JACOB%ENT(1,1)*SECOND_PD%Y(2)-SECOND_PD%X(2)*JACOB%ENT(2,1)-JACOB%ENT(1,2)*SECOND_PD%Y(1)
! 	JETA = SECOND_PD%X(2)*JACOB%ENT(2,2)+JACOB%ENT(1,1)*SECOND_PD%Y(3)-SECOND_PD%X(3)*JACOB%ENT(2,1)-JACOB%ENT(1,2)*SECOND_PD%Y(2)

! 	S(1,1) = -(JXI*JACOB%ENT(2,2)*JACOB%ENT(2,2)-JETA*JACOB%ENT(2,1)*JACOB%ENT(2,2))/J**3+(SECOND_PD%Y(2)*JACOB%ENT(2,2)-SECOND_PD%Y(3)*JACOB%ENT(2,1))/J**2
! 	S(1,2) = (JXI*JACOB%ENT(1,2)*JACOB%ENT(2,2)-JETA*JACOB%ENT(1,2)*JACOB%ENT(2,1))/J**3-(SECOND_PD%X(2)*JACOB%ENT(2,2)-SECOND_PD%X(3)*JACOB%ENT(2,1))/J**2
! 	S(1,3) = -(JXI*JACOB%ENT(1,2)*JACOB%ENT(1,2)-JETA*JACOB%ENT(1,1)*JACOB%ENT(1,2))/J**3+(SECOND_PD%X(2)*JACOB%ENT(1,2)-SECOND_PD%X(3)*JACOB%ENT(1,1))/J**2
! 	S(2,1) = (JXI*JACOB%ENT(2,1)*JACOB%ENT(2,2)-JETA*JACOB%ENT(2,1)*JACOB%ENT(2,1))/J**3-(SECOND_PD%Y(1)*JACOB%ENT(2,2)-SECOND_PD%Y(2)*JACOB%ENT(2,1))/J**2
! 	S(2,2) = -(JXI*JACOB%ENT(1,1)*JACOB%ENT(2,2)-JETA*JACOB%ENT(1,1)*JACOB%ENT(2,1))/J**3+(SECOND_PD%X(1)*JACOB%ENT(2,2)-SECOND_PD%X(2)*JACOB%ENT(2,1))/J**2
! 	S(2,3) = (JXI*JACOB%ENT(1,1)*JACOB%ENT(1,2)-JETA*JACOB%ENT(1,1)*JACOB%ENT(1,1))/J**3-(SECOND_PD%X(1)*JACOB%ENT(1,2)-SECOND_PD%X(2)*JACOB%ENT(1,1))/J**2

	REF_SF = GET_BASIS(REF_PT,(/IX,IY/), PATCH)

	GET_PHY_BASIS%D00 = REF_SF%VAL(0,0)
	GET_PHY_BASIS%D10 = REF_SF%VAL(1,0)*INV_JACOB%ENT(1,1) + REF_SF%VAL(0,1)*INV_JACOB%ENT(2,1)
	GET_PHY_BASIS%D01 = REF_SF%VAL(1,0)*INV_JACOB%ENT(1,2) + REF_SF%VAL(0,1)*INV_JACOB%ENT(2,2)
! 	GET_PHY_BASIS%D20 = REF_SF%VAL(2,0)*INV_JACOB%ENT(1,1)**2 + 2.0D0*REF_SF%VAL(1,1)*INV_JACOB%ENT(1,1)*INV_JACOB%ENT(2,1) + REF_SF%VAL(0,2)*INV_JACOB%ENT(2,1)**2 + REF_SF%VAL(1,0)*S(1,1) + REF_SF%VAL(0,1)*S(2,1)
! 	GET_PHY_BASIS%D11 = REF_SF%VAL(2,0)*INV_JACOB%ENT(1,1)*INV_JACOB%ENT(1,2) + REF_SF%VAL(1,1)*(INV_JACOB%ENT(1,1)*INV_JACOB%ENT(2,2)+INV_JACOB%ENT(1,2)*INV_JACOB%ENT(2,1)) + REF_SF%VAL(0,2)*INV_JACOB%ENT(2,1)*INV_JACOB%ENT(2,2) + REF_SF%VAL(1,0)*S(1,2) + REF_SF%VAL(0,1)*S(2,2)
! 	GET_PHY_BASIS%D02 = REF_SF%VAL(2,0)*INV_JACOB%ENT(1,2)**2 + 2.0D0*REF_SF%VAL(1,1)*INV_JACOB%ENT(1,2)*INV_JACOB%ENT(2,2) + REF_SF%VAL(0,2)*INV_JACOB%ENT(2,2)**2 + REF_SF%VAL(1,0)*S(1,3) + REF_SF%VAL(0,1)*S(2,3)

END FUNCTION GET_PHY_BASIS

!! FIND ALL NONVANISHING BASIS FUNCTION ON PHYSICAL SPACE
SUBROUTINE GET_ALL_PHY_BASIS_IN_INT(SF, INDX, REF_PT, JACOB, PATCH)
	INTEGER, INTENT(IN) :: PATCH
	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB

	TYPE(DIFF_BSPLINES) :: NX, NY
	TYPE(MATRIX_22) :: INV_JACOB
	
	INV_JACOB = .INVERSE.JACOB
	
	NX = GET_ALL_DIFF_BSPLINES(REF_PT%X, BASIS_KVEC(PATCH,1), 1)
	NY = GET_ALL_DIFF_BSPLINES(REF_PT%Y, BASIS_KVEC(PATCH,2), 1)

	K = 0
	DO J=0, NY%POLY_ORDER
		DO I=0, NX%POLY_ORDER
			K = K + 1
			SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
			SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
			SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
			INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
		ENDDO
	ENDDO
! 	PRINT*, INDX(1),SF(1)
! 	STOP
END SUBROUTINE GET_ALL_PHY_BASIS_IN_INT

!! FIND ALL NONVANISHING BASIS FUNCTION ON PHYSICAL SPACE
SUBROUTINE GET_ALL_PHY_BASIS(SF, INDX, REF_PT, PATCH)
	INTEGER, INTENT(IN) :: PATCH
	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(PATCH,1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH,2)%POLY_ORDER+1))
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	

	TYPE(DIFF_BSPLINES) :: NX, NY
	TYPE(MATRIX_22) :: INV_JACOB, JACOB
	
	JACOB = GET_JACOBIAN_MATRIX(REF_PT, PATCH)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
	INV_JACOB = .INVERSE.JACOB
	
	NX = GET_ALL_DIFF_BSPLINES(REF_PT%X, BASIS_KVEC(PATCH,1), 1)
	NY = GET_ALL_DIFF_BSPLINES(REF_PT%Y, BASIS_KVEC(PATCH,2), 1)

	K = 0
	DO J=0, NY%POLY_ORDER
		DO I=0, NX%POLY_ORDER
			K = K + 1
			SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
			SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
			SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
			INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
		ENDDO
	ENDDO

END SUBROUTINE GET_ALL_PHY_BASIS

!!  FIND BASIS FUNCTION ON PARAMETRIC SPACE
TYPE(FUNCTION_2D) FUNCTION GET_BASIS(REF_PT,INDX, PATCH)

	TYPE(POINT2D), INTENT(IN) :: REF_PT
	INTEGER, INTENT(IN) :: INDX(2), PATCH

	TYPE(FUNCTION_1D) :: NX, NY

	NX = GET_DIFF_BSPLINE(REF_PT%X,BASIS_KVEC(PATCH,1),INDX(1),1)
	NY = GET_DIFF_BSPLINE(REF_PT%Y,BASIS_KVEC(PATCH,2),INDX(2),1)

	GET_BASIS%VAL(0,0) = NX%VAL(0) * NY%VAL(0)
	GET_BASIS%VAL(1,0) = NX%VAL(1) * NY%VAL(0)
	GET_BASIS%VAL(0,1) = NX%VAL(0) * NY%VAL(1)
! 	GET_BASIS%VAL(2,0) = NX%VAL(2) * NY%VAL(0)
! 	GET_BASIS%VAL(1,1) = NX%VAL(1) * NY%VAL(1)
! 	GET_BASIS%VAL(0,2) = NX%VAL(0) * NY%VAL(2)

END FUNCTION GET_BASIS

END MODULE NURBS_BASIS