MODULE BOUNDARY

	USE INTEGRATION
	USE LUDECOMPOSITION

  implicit integer (i-n)
	implicit real(8) (a-h,o-z)

CONTAINS

SUBROUTINE IMPOSEBD(K, F)

	REAL*8, INTENT(INOUT) :: K(2*DOF,2*DOF), F(2*DOF)
	REAL*8 :: SUB_K(SUM(DR_BDNDX(:,1)%LC_NUM),SUM(DR_BDNDX(:,1)%LC_NUM))
	TYPE(POINT2D) :: DMY_SUB_F(SUM(DR_BDNDX(:,1)%LC_NUM))
	
	TYPE(POINT2D) :: PINCH_DISP(2), SUB_F(SUM(DR_BDNDX(:,1)%LC_NUM))
	REAL*8 :: DMY_SUB_K(SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM)), DD
	INTEGER :: I, J, II, JJ, KK, INDX(SUM(DR_BDNDX(:,1)%LC_NUM)), PINCH_BS_INDX(2), LC_NUM_SUM
	TYPE(POINT2D) :: LN_INT

	DO I=1, 2*DOF
		DO J=1, 2*DOF
			IF (DABS(K(I,J)).LE.EPS) THEN
				K(I,J) = 0.D0
			ENDIF
		ENDDO
	ENDDO
	
! IMPOSE NEUMANN BOUNDARY CONDITION
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 	DO J=1, NEUMANN_NUMBD
! 		DO I=1, NEUMANN_BDNDX(J,1)%LC_NUM
! ! 			PRINT*, NEUMANN_BDNDX(J,1)%LC_NUM
! 			LN_INT = INT_F_LN(NEUMANN_BDNDX(J,I),J)
! 			F(NEUMANN_BDNDX(J,I)%GL_NDX) = F(NEUMANN_BDNDX(J,I)%GL_NDX) + LN_INT%X
! 			F(DOF + NEUMANN_BDNDX(J,I)%GL_NDX) = F(DOF + NEUMANN_BDNDX(J,I)%GL_NDX) + LN_INT%Y
! 		ENDDO
! 	ENDDO
! 
! ! PINCH TWO POINTS IN THE CASE OF IMPOSING NEUMANN B.C. ON ALL BOUNDARY
! 	PINCH_DISP(1) = EX_DISP(POINT2D(0.D0,1.D0),1) !<----- CAUTION!!!!! PUT A REFERENCE POINT CORRESPONDING TO A PINCH POINT ON PHYSICAL DOMAIN
! 	PINCH_DISP(2) = EX_DISP(POINT2D(1.D0,1.D0),2) !<----- CAUTION!!!!! PUT A REFERENCE POINT CORRESPONDING TO A PINCH POINT ON PHYSICAL DOMAIN
! 
! 	DO J=1, 2*DOF
! 		F(J) = F(J) - PINCH_DISP(1)%X*K(J,LOCAL_DOF(1)-NUMBS(1)+1) - PINCH_DISP(1)%Y*K(J, DOF + LOCAL_DOF(1)-NUMBS(1)+1)
! 		F(J) = F(J) - PINCH_DISP(2)%X*K(J,DOF) - PINCH_DISP(2)%Y*K(J, 2*DOF)
! 	ENDDO
! 
! 	F(LOCAL_DOF(1)-NUMBS(1)+1) = PINCH_DISP(1)%X; F(DOF) = PINCH_DISP(2)%X
! 	F(DOF + LOCAL_DOF(1)-NUMBS(1)+1) = PINCH_DISP(1)%Y; F(2*DOF) = PINCH_DISP(2)%Y
! 	DO J=1, 2*DOF
! 		K(LOCAL_DOF(1)-NUMBS(1)+1,J) = 0.0D0; K(DOF,J) = 0.D0
! 		K(DOF + LOCAL_DOF(1)-NUMBS(1)+1,J) = 0.0D0; K(2*DOF, J) = 0.D0
! 
! 		K(J,LOCAL_DOF(1)-NUMBS(1)+1) = 0.0D0; K(J,DOF) = 0.D0
! 		K(J,DOF + LOCAL_DOF(1)-NUMBS(1)+1) = 0.0D0; K(J,2*DOF) = 0.D0
! 	ENDDO
! 	K(LOCAL_DOF(1)-NUMBS(1)+1, LOCAL_DOF(1)-NUMBS(1)+1) = 1.0D0; K(DOF,DOF) = 1.D0
! 	K(DOF + LOCAL_DOF(1)-NUMBS(1)+1, DOF + LOCAL_DOF(1)-NUMBS(1)+1) = 1.0D0; K(2*DOF,2*DOF) = 1.D0
! 
! 	PRINT*, 
! 	PRINT*, '<<< IMPOSING NEUMANN BOUNDARY CONDITIONS : DONE >>>'
! 	PRINT*, 

! IMPOSE DIRICHLET BOUNDARY CONDITION BY USING LEAST SQUARE METHOD
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	SUB_K(:,:) = 0.D0
	SUB_F(:) = POINT2D(0.D0,0.D0)

! 	OPEN(121, FILE = 'least_square')
	
	CALL GEN_BD_LN(SUB_K, SUB_F)
	
! 	CALL DR_BUGKILLER(SUB_K, SUB_F)

	DMY_SUB_F = SUB_F
	
! 	PRINT*, 'HERE 1'
! 	OPEN(124, FILE = './data/sub_k')
! 	OPEN(125, FILE = './data/sub_f')
! 	DO I=1, SUM(DR_BDNDX(:,1)%LC_NUM)
! 		WRITE(124, 102) (SUB_K(I,J), J=1, SUM(DR_BDNDX(:,1)%LC_NUM))
! 		WRITE(125, 102) SUB_F(I)
! 	ENDDO
! 	CLOSE(124)
! 	CLOSE(125)
	
	102 FORMAT(1000(f20.8,1x))
	
	DMY_SUB_K(:,:) = SUB_K(:,:)
	CALL LUDCMP(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, DD)
	CALL LUBKSB(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, SUB_F(:)%X)
! 	PRINT*, 'HERE 2'
	DMY_SUB_K(:,:) = SUB_K(:,:)
	CALL LUDCMP(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, DD)
	CALL LUBKSB(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, SUB_F(:)%Y)
! 	PRINT*, 'HERE 3'

! 	SUBTRACT EXACT SOLUTIONS FROM THE LOAD VECTOR
	DO II=1, NUM_PATCH
		IF (II.EQ.1) THEN
			LC_NUM_SUM = 0
		ELSE
			LC_NUM_SUM = SUM(DR_BDNDX(1:II-1,1)%LC_NUM)
		ENDIF
! 					PRINT*, LC_NUM_SUM
		DO I=1, DR_BDNDX(II,1)%LC_NUM
			DO J=1, 2*DOF
				F(J) = F(J) - SUB_F(LC_NUM_SUM + I)%X*K(J, DR_BDNDX(II,I)%GL_NDX) - SUB_F(LC_NUM_SUM + I)%Y*K(J, DOF + DR_BDNDX(II,I)%GL_NDX)
			ENDDO
		ENDDO
	ENDDO

! PRINT*, 'HERE 4'

	DO II=1, NUM_PATCH
		IF (II.EQ.1) THEN
			LC_NUM_SUM = 0
		ELSE
			LC_NUM_SUM = SUM(DR_BDNDX(1:II-1,1)%LC_NUM)
		ENDIF
		DO I=1, DR_BDNDX(II,1)%LC_NUM
			F(DR_BDNDX(II,I)%GL_NDX) = SUB_F(LC_NUM_SUM + I)%X
			F(DOF + DR_BDNDX(II,I)%GL_NDX) = SUB_F(LC_NUM_SUM + I)%Y
! 			PRINT*, F(DR_BDNDX(II,I)%GL_NDX), F(DOF+BDNDX(II,I)%GL_NDX)
			DO J=1, 2*DOF
				K(DR_BDNDX(II,I)%GL_NDX,J) = 0.0D0
				K(J,DR_BDNDX(II,I)%GL_NDX) = 0.0D0
				K(DOF + DR_BDNDX(II,I)%GL_NDX,J) = 0.0D0
				K(J, DOF + DR_BDNDX(II,I)%GL_NDX) = 0.0D0
			ENDDO
			K(DR_BDNDX(II,I)%GL_NDX, DR_BDNDX(II,I)%GL_NDX) = 1.0D0
			K(DOF + DR_BDNDX(II,I)%GL_NDX, DOF + DR_BDNDX(II,I)%GL_NDX) = 1.0D0
		ENDDO
	ENDDO
	
! 	F(1) = 0.D0
! 	F(DOF + 1) = 0.D0
! 	DO J=1, 2*DOF
! 		K(1,J) = 0.D0
! 		K(J,1) = 0.D0
! 		K(DOF + 1,J) = 0.D0
! 		K(J,DOF + 1) = 0.D0
! 	ENDDO
! 	K(1,1) = 1.D0
! 	K(DOF + 1, DOF + 1) = 1.D0
	
	PRINT*, 
	PRINT*, '<<< IMPOSING ESSENTIAL BOUNDARY CONDITIONS BY USING LEAST SQUARE METHOD : DONE >>>'
	PRINT*, 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


END SUBROUTINE IMPOSEBD

! SUBROUTINE DR_BUGKILLER(SUB_K, SUB_F)
! 
! 	REAL*8, INTENT(IN) :: SUB_K(SUM(DR_BDNDX(:,1)%LC_NUM),SUM(DR_BDNDX(:,1)%LC_NUM))
! 	TYPE(POINT2D), INTENT(IN) :: SUB_F(SUM(DR_BDNDX(:,1)%LC_NUM))
! 	
! 	REAL*8 :: BD_INT(3), BD_WEIGHT(NUMGSPT), DET_JF, DET_M
! 	TYPE(POINT2D) :: GSPT, PHYPT_F, INV_PHYPT_G
! 	TYPE(POINT2D) :: EXBD(NUMGSPT)
! 	TYPE(FVALUE) :: BD_SF(2,NUMGSPT)
! 	INTEGER :: I, J, K, II, JJ, KK, PATCH
! 	TYPE(MATRIX_22) :: JACOB_F, JACOB_G, JACOB
! 	
! 	!----- CHECK DIRICHLET BOUNDARY -----!
! 	! (1) SUB_K (5,5), SUB_F(5)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	PATCH = 1
! 	CALL GAULEG(0.D0, 1.D0, GSX, GSXW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(GSX(I),0.D0)
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT,PATCH)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSXW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 4, 0, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(1,:)%D00)
! 	BD_INT(3) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! 	PATCH = 1
! 	CALL GAULEG(0.D0, 1.D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(1.D0, GSY(I))
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, PATCH)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT,4, 0, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(2) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(1,:)%D00)
! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! ! 	PRINT*, SUB_K(5,5), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(5,5) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(5,5) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! ! 	PRINT*, SUB_F(5)%X, BD_INT(3)
! 	IF (DABS(SUB_F(5)%X - BD_INT(3)).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_F(5) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! 	
! 	! (1) SUB_K (22,28), SUB_F(22)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	
! 	PATCH = 3
! 	
! 	CALL GAULEG(0.D0, 1.D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(0.D0, GSY(I))
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, PATCH)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 0, 0, PATCH)
! 		BD_SF(2,I) = GET_PHY_BASIS(GSPT, 0, 2, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! ! 	PRINT*, SUB_K(22,28), BD_INT(1)
! 	IF (DABS(SUB_K(22,28) - BD_INT(1)).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(22,28)'
! 	ENDIF
! 	
! 	
! 	! (1) SUB_K (14,14), SUB_F(14)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	
! 	PATCH = 2
! 	
! 	CALL GAULEG(0.D0, 1.D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(0.D0, GSY(I))
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, PATCH)
! 		DET_M = DABS(.DETERMINANT.JACOB)
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 0, 0, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! ! 		PRINT*, PATCH, EXBD(I)%X
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(1,:)%D00)
! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! ! 	PRINT*, PATCH, BD_INT(3)
! 	PATCH = 3
! 	
! 	CALL GAULEG(0.D0, 1.D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(0.D0, GSY(I))
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, PATCH)
! 		DET_M = DABS(.DETERMINANT.JACOB)
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(2,I) = GET_PHY_BASIS(GSPT, 0, 4, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! ! 		PRINT*, PATCH, DET_M, BD_SF(2,I)%D00, EXBD(I)%X
! 	ENDDO
! 	BD_INT(2) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(2,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(2,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! ! 	PRINT*, PATCH, DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(2,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 	
! ! 	PRINT*, SUB_K(14,14), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(14,14) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(14,14) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! ! 	PRINT*, SUB_F(14)%X, BD_INT(14)
! 	IF (DABS(SUB_F(14)%X - BD_INT(3)).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_F(14) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! 	! (1) SUB_K (26,31)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	PATCH = 4
! 	
! 	CALL GAULEG(0.D0, 1.D0, GSX, GSXW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(GSX(I),0.D0)
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT,PATCH)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSXW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 0, 0, PATCH)
! 		BD_SF(2,I) = GET_PHY_BASIS(GSPT, 2, 0, PATCH)
! ! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! ! 	BD_INT(3) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 
! ! 	PRINT*, SUB_K(26,31), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(26,31) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(26,31) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! 	! (1) SUB_K (45,45), SUB_F(45)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	
! 	PATCH = 5
! 	
! 	CALL GAULEG(0.D0, 0.9D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(0.D0, GSY(I))
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, PATCH)
! 		DET_M = DABS(.DETERMINANT.JACOB)
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 0, 2, PATCH)
! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(1,:)%D00)
! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 
! ! 	PRINT*, SUB_K(45,45), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(45,45) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(45,45) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! ! 	PRINT*, SUB_F(45)%X, BD_INT(3)
! 	IF (DABS(SUB_F(45)%X - BD_INT(3)).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_F(45) - ', 'INTERFACE NODE ON BOUNDARY'
! 	ENDIF
! 	
! 	! (1) SUB_K (48,5)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	
! 	CALL GAULEG(0.D0, 0.9D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(1.D0, GSY(I))
! 		PHYPT_F = GET_PHY_PT(GSPT, 5)
! 		INV_PHYPT_G = GET_REF_PT(PHYPT_F, 1)
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, 5)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 16, 3, 5)
! 		BD_SF(2,I) = GET_PHY_BASIS(INV_PHYPT_G, 4, 0, 1)
! ! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! ! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 
! 	CALL GAULEG(0.9D0, 1.D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(1.D0, GSY(I))
! 		PHYPT_F = GET_PHY_PT(GSPT, 5)
! 		INV_PHYPT_G = GET_REF_PT(PHYPT_F, 1)
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, 5)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 16, 3, 5)
! 		BD_SF(2,I) = GET_PHY_BASIS(INV_PHYPT_G, 4, 0, 1)
! ! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(2) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! ! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 
! ! 	PRINT*, SUB_K(48,5), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(48,5) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(48,5)'
! 	ENDIF
! 	
! 	! (1) SUB_K (43,39)
! 	BD_INT(:) = 0.D0
! 	BD_SF(:,:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)
! 	
! 	CALL GAULEG(0.D0, 0.9D0, GSY, GSYW, NUMGSPT)
! 	DO I=1,NUMGSPT
! 		GSPT = POINT2D(0.D0, GSY(I))
! 		PHYPT_F = GET_PHY_PT(GSPT, 5)
! 		INV_PHYPT_G = GET_REF_PT(PHYPT_F, 4)
! 		JACOB = GET_JACOBIAN_MATRIX(GSPT, 5)
! 		DET_M = .DETERMINANT.JACOB
! 		BD_WEIGHT(I) = DET_M*GSYW(I)
! 		BD_SF(1,I) = GET_PHY_BASIS(GSPT, 0, 1, 5)
! 		BD_SF(2,I) = GET_PHY_BASIS(INV_PHYPT_G, 3, 4, 4)
! ! 		EXBD(I) = EX_DISP(GSPT, PATCH)
! 	ENDDO
! 	BD_INT(1) = DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), BD_SF(2,:)%D00)
! ! 	BD_INT(3) = BD_INT(3) + DOT_PRODUCT(PRODUCT(RESHAPE((/BD_SF(1,:)%D00, BD_WEIGHT(:)/), (/NUMGSPT, 2/), ORDER=ORDER1), 2), EXBD(:)%X)
! 
! ! 	PRINT*, SUB_K(43,39), (BD_INT(1) + BD_INT(2))
! 	IF (DABS(SUB_K(43,39) - (BD_INT(1) + BD_INT(2))).GT.EPS) THEN
! 		PRINT*, 'FOUND BUG! - ', 'SUB_K(43,39)'
! 	ENDIF
! 	
! END SUBROUTINE DR_BUGKILLER

END MODULE BOUNDARY
