MODULE ERRORESTIMATE

	USE GEOMETRY
	USE NURBS_BASIS
	USE LOADFUNCTION
	USE GSQUAD

    IMPLICIT NONE
    
CONTAINS

!----MAX. NORM ESTIMATE----
SUBROUTINE MAXNORM(MAX_NORM, COEFF_SOL)

	REAL*8, INTENT(OUT) :: MAX_NORM(5)
	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
	
	TYPE(POINT2D) :: MESH, PHY_PT, REF_PT, PAR_PT
	TYPE(INT2D) :: MAXGRID
	INTEGER :: II, JJ, I, J, PATCH_ROW, PATCH_COLUMN, NUMGSPT, N
	TYPE(RECPATCH) :: IRBOX
	TYPE(DISPLACEMENT) :: EXDISP, APDISP, ERR_DISP, ERR_LINE_DISP, ERR_POLAR_DISP, TMP_ERR_DISP, MAXDISP
	TYPE(STRESS) :: EXSTR, APSTR, ERR_STR, TMP_ERR_STR, ERR_LINE_STR, ERR_POLAR_STR
	REAL*8 :: R, THETA
	INTEGER :: PATCH
	
	MAX_NORM(:) = 0.0D0
	
	ERR_STR = STRESS(0.D0,0.D0,0.D0,0.D0,0.D0)
	ERR_DISP = DISPLACEMENT(0.D0,0.D0,0.D0)
	TMP_ERR_DISP = DISPLACEMENT(0.D0,0.D0,0.D0)
	MAXDISP = DISPLACEMENT(0.D0,0.D0,0.D0)
	
! 	print*, 'here-1'
	
	OPEN(11, FILE = './data/ext_disp')
	OPEN(21, FILE = './data/app_disp')
	OPEN(31, FILE = './data/err_disp')
	
	DO I = 0, 100
		DO J = 0, 99
			PAR_PT = POINT2D(0.010D0*I, 0.010D0*J)
			PHY_PT = GET_PHY_PT(PAR_PT)
			IF (PDE=='CNVD' .AND. PROBLEM==4 .AND. (DABS(PHY_PT%X - 1.0D0)<=EPS .AND. DABS(PHY_PT%Y)<=EPS) .OR. (DABS(PHY_PT%X + 1.0D0)<=EPS .AND. DABS(PHY_PT%Y)<=EPS)) THEN
! 				PRINT*, I,J,PHY_PT
				GOTO 123
			ENDIF
			CALL APPROXSOL(APDISP%PIX, PAR_PT, COEFF_SOL)
			EXDISP%PIX = EX_DISP(PAR_PT)
			TMP_ERR_DISP%PIX = DABS(EXDISP%PIX - APDISP%PIX)
			
			WRITE(11,*) PHY_PT, EXDISP%PIX
			WRITE(21,*) PHY_PT, APDISP%PIX
			WRITE(31,*) PHY_PT, TMP_ERR_DISP%PIX
			
			IF (TMP_ERR_DISP%PIX.GE.ERR_DISP%PIX) THEN
				ERR_DISP%PIX = TMP_ERR_DISP%PIX
			ENDIF
			IF (DABS(EXDISP%PIX).GE.MAXDISP%PIX) THEN
				MAXDISP%PIX = DABS(EXDISP%PIX)
			ENDIF
			123 CONTINUE
		ENDDO
		WRITE(11,*) ""
		WRITE(21,*) ""
		WRITE(31,*) ""
	ENDDO
	CLOSE(11)
	CLOSE(21)
	CLOSE(31)
	
	
	
! 	write(char_order(1),fmt='(i2.2)') BS_ORDER(1)
! 	write(char_order(2),fmt='(i2.2)') BS_ORDER(2)
! 	write(char_basis(1),fmt='(i2.2)') NUMBS(1)
! 	write(char_basis(2),fmt='(i2.2)') NUMBS(2)

! 	filename = trim('./data/pro') // char_problem // trim('_') // trim('result_p') // char_order(1) // trim('X') // char_order(2) // trim('_b') // char_basis(1) // trim('X') // char_basis(2)

! 	open(13,file=filename,status='unknown')
! 	WRITE(13,*) "ORDER OF B-SPLINE : ", BS_ORDER
! 	IF (EXTRA_KNOTS(1).EQ.0 .AND. EXTRA_KNOTS(2).EQ.0) THEN
! 		WRITE(13,*) "KNOT INSERTION : NONE"
! 	ELSE
! 		WRITE(13,*) "KNOT INSERTION : ", EXTRA_KNOTS
! 	ENDIF
! 	WRITE(13,*) "BOUNDARY CONDITION : ", BCTYPE
! 	WRITE(13,*) "NUMBER OF BASIS FTS : ", NUMBS
! 	WRITE(13,*) 'DEGREE OF FREEDOM : ', DOF - BD_DOF
! 	WRITE(13,*) 'DEGREE OF FREEDOM ON BOUNDARY : ', BD_DOF
! 	WRITE(13,*) ""
! 	WRITE(13,*) "MAXIMUM ERROR (%) : ", ERR_DISP%PIX*100.D0
! 	CLOSE(13)

	PRINT*, 'MAXDISP= ', MAXDISP%PIX
	PRINT*, 'ERR_DISP= ', ERR_DISP%PIX
	
	MAX_NORM(1) = ERR_DISP%PIX*100.D0/MAXDISP%PIX
	
END SUBROUTINE MAXNORM

SUBROUTINE ENRGY(ENRG, DMY_K, SOL)

	REAL*8, INTENT(IN) :: DMY_K(DOF,DOF), SOL(DOF)
	REAL*8, INTENT(OUT) :: ENRG(4)
	REAL*8 :: AP, TR
	INTEGER :: I, J

	AP = 0.50D0*DOT_PRODUCT(SOL, MATMUL(DMY_K, SOL))
	
	IF (PDE=='ELPT') THEN
		IF (PROBLEM==0) THEN
			TR = 0.196350D0
		ELSEIF (PROBLEM.EQ.1) THEN
			TR = PI/4.D0
		ELSEIF (PROBLEM.EQ.2) THEN
			TR = 0.785398163397448280D0
		ELSEIF (PROBLEM.EQ.3) THEN
			TR = 2.0943951023931948D0
		ELSEIF (PROBLEM==4) THEN
			TR = 0.91811333093758096258D0
		ENDIF
	ELSEIF (PDE=='CNVD') THEN
		IF (PROBLEM==1) THEN
			TR = 0.50D0*0.03926990D0
		ELSEIF (PROBLEM.EQ.2) THEN
			TR = 0.50d0*0.001036290d0
		ELSEIF (PROBLEM.EQ.3) THEN
			TR = 0.50d0*0.06509790d0
		ELSEIF (PROBLEM==4) THEN
			IF (DABS(EPSLN - 0.10D0)<=EPS) THEN
				TR = 0.50D0*0.154080d0
			ENDIF
			IF (DABS(EPSLN - 0.0010D0)<=EPS) THEN
				TR = 0.7421950D0
			ENDIF
		ENDIF
	ENDIF
		

! 	CALL EXT_ENERGY(TR)

	ENRG(3) = DSQRT(DABS(AP - TR))*100.D0
	ENRG(4) = DSQRT(DABS(AP - TR) / TR)*100.D0

	ENRG(1) = TR; ENRG(2) = AP

!   OPEN(13, FILE=filename, STATUS='unknown', POSITION='append')
! 	WRITE(13,*) ''
! 	WRITE(13,*) 'EXACT ENERGY : ', ENRG(1)
! 	WRITE(13,*) 'APPR. ENERGY : ', ENRG(2)
! 	WRITE(13,*) 'ABS.  ENERGY NORM ERROR (%) : ', ENRG(3)
! 	WRITE(13,*) 'REL.  ENERGY NORM ERROR (%) : ', ENRG(4)
! 	CLOSE(13)
! 

	WRITE(*,*) ""
	WRITE(*,*) 'APPR. ENERGY : ', AP
	PRINT*, ""
	PRINT*, 'REL.  ENERGY NORM ERROR (%) : ', ENRG(4)
	PRINT*, ""


END SUBROUTINE ENRGY

SUBROUTINE L2_NORM_ERROR(L2_NORM, COEFF_SOL)
	
	REAL*8, INTENT(OUT) :: L2_NORM(2)
	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
	
	INTEGER :: I, J, II, JJ, N, KK, K, PATCH, PATCH_COLUMN, PATCH_ROW
	REAL*8 :: WEIGHT, DIFF_NN, DET_M
	REAL*8, ALLOCATABLE :: L2_GSX(:), L2_GSXW(:), L2_GSY(:), L2_GSYW(:)
	TYPE(POINT2D) :: GSPT, PHY_PT
	TYPE(MATRIX_22) :: JACOB
	TYPE(DISPLACEMENT) :: EXDISP, APDISP, INTF(2)
	TYPE(STRESS) :: APSTRESS
	TYPE(RECPATCH) :: IRBOX
	
	IF (USE_ENRICH=='Y') THEN
		N = 2*(PUORDER + SUM(BS_ORDER(1, 3, :))) + 10
	ELSE 
		N = 2*(PUORDER + SUM(BS_ORDER(1, 3, :)))
	ENDIF
	
	ALLOCATE(L2_GSX(N), L2_GSY(N), L2_GSXW(N), L2_GSYW(N))
	
	PATCH_ROW = 1
	
	INTF(:) = DISPLACEMENT(0.D0,0.D0,0.D0)
	
	DO PATCH_COLUMN = 1, NUMPATCH(2)
		DO II = 1, L2_NUMIR(1) - 1
			DO JJ = 1, L2_NUMIR(2) - 1
				IRBOX%PT1 = POINT2D(L2_GRID(1,II), L2_GRID(2,JJ))
				IRBOX%PT2 = POINT2D(L2_GRID(1,II+1), L2_GRID(2,JJ))
				IRBOX%PT3 = POINT2D(L2_GRID(1,II+1), L2_GRID(2,JJ+1))
				IRBOX%PT4 = POINT2D(L2_GRID(1,II), L2_GRID(2,JJ+1))
				!------------------! VECTORIZE GAUSS POINTS AND WEIGHTS------------------------------
				CALL GAULEG(IRBOX%PT1%X, IRBOX%PT2%X, L2_GSX, L2_GSXW, N)
				CALL GAULEG(IRBOX%PT1%Y, IRBOX%PT4%Y, L2_GSY, L2_GSYW, N)
				DO KK = 1, N
					DO K = 1, N
						GSPT = POINT2D(L2_GSX(KK),L2_GSY(K))
						JACOB= GET_JACOBIAN_MATRIX(GSPT)
						DET_M = .DETERMINANT.JACOB
! 							PHY_PT = GET_PHY_PT(DMY_GSPT)
						EXDISP%PIX = EX_DISP(GSPT)
						CALL APPROXSOL(APDISP%PIX, GSPT, COEFF_SOL)
						INTF(1)%PIX = INTF(1)%PIX + (EXDISP%PIX - APDISP%PIX)**2*DET_M*L2_GSXW(KK)*L2_GSYW(K)
						INTF(2)%PIX = INTF(2)%PIX + EXDISP%PIX**2*DET_M*L2_GSXW(KK)*L2_GSYW(K)
					ENDDO
				ENDDO
			ENDDO
		ENDDO
	ENDDO
	
	L2_NORM(1) = DSQRT(INTF(1)%PIX/INTF(2)%PIX)*100.D0
! 	L2_NORM(2) = DSQRT(INTF(1)%PIY/INTF(2)%PIY)*100.D0
	
! 	OPEN(13, FILE=filename, STATUS='unknown', POSITION='append')
! 	WRITE(13,*) ''
! 	WRITE(13,*) 'RELATIVE ERROR IN L2 NORM (%) OF DISPLACEMENT ALONG X-DIRECTION : ', L2_NORM(1)
! 	WRITE(13,*) 'RELATIVE ERROR IN L2 NORM (%) OF DISPLACEMENT ALONG Y-DIRECTION : ', L2_NORM(2)
! 	CLOSE(1)
	
END SUBROUTINE L2_NORM_ERROR

SUBROUTINE APPROXSOL(APDISP, PAR_PT, COEFF_SOL)

	TYPE(POINT2D), INTENT(IN) :: PAR_PT
	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
	REAL*8, INTENT(OUT) :: APDISP

	TYPE(FVALUE) :: SF(DOF)
	TYPE(FVALUE), ALLOCATABLE :: LOCAL_SF(:)
	TYPE(INT2D), ALLOCATABLE :: INDX(:)
	TYPE(MATRIX_22) :: JACOB
	
	INTEGER :: I, J, II, JJ, KK, GLOBAL_INDX, PATCH_ROW, PATCH_COLUMN

	APDISP = 0.D0
	SF(:) = FVALUE(0.D0,0.D0,0.D0,0.D0,0.D0,0.D0)

	JACOB = GET_JACOBIAN_MATRIX(PAR_PT)

	PATCH_ROW = 1
	
	DO PATCH_COLUMN = 1, NUMPATCH(2)
	
		ALLOCATE(LOCAL_SF((BASIS_KVEC(PATCH_ROW, PATCH_COLUMN, 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH_ROW, PATCH_COLUMN, 2)%POLY_ORDER+1)))
		ALLOCATE(INDX((BASIS_KVEC(PATCH_ROW, PATCH_COLUMN, 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCH_ROW, PATCH_COLUMN, 2)%POLY_ORDER+1)))
		
		CALL GET_PATCHWISE_BS(LOCAL_SF(:), INDX(:), PAR_PT, (/PATCH_ROW, PATCH_COLUMN/), JACOB)
! 	CALL GET_ALL_PHY_BASIS_IN_INT(LOCAL_SF(:), INDX, PAR_PT, JACOB)
! 	CALL GET_ALL_PHY_NURBS_SURFACE_2D(LOCAL_SF(:), INDX, PAR_PT, JACOB)
		
		DO JJ = 1, UBOUND(LOCAL_SF,1)
			DO II = 1, DOF
				IF (NDX(1,II)==PATCH_ROW .AND. NDX(2,II)==PATCH_COLUMN .AND. NDX(3,II).EQ.INDX(JJ)%A .AND. NDX(4,II).EQ.INDX(JJ)%B) THEN
					GLOBAL_INDX = II
					GOTO 111
				ENDIF
			ENDDO
			GLOBAL_INDX = 0
			111 CONTINUE
			IF (GLOBAL_INDX.NE.0) THEN
				SF(GLOBAL_INDX)%D00 = SF(GLOBAL_INDX)%D00 + LOCAL_SF(JJ)%D00
			ENDIF
		ENDDO
		DEALLOCATE(LOCAL_SF, INDX)
	ENDDO
	
	APDISP = DOT_PRODUCT(COEFF_SOL(1:DOF), SF(:)%D00)
	
END SUBROUTINE APPROXSOL

END MODULE ERRORESTIMATE
