MODULE NURBS_BASIS

	USE GLBVAR
	USE PATCH_MAPPING

	IMPLICIT INTEGER (I-N)
	IMPLICIT REAL(8) (A-H,O-Z)

CONTAINS

!!  GET BASIS FUNCTION ON PHYSICAL SPACE


!! ----------------------------- [[[[[ MODIFIED B-SPLINE BASIS FUNCTIONS FOR INTEGRATION]]]]] ----------------------------- 
!-----------------------------------------------------------------------------------------------------------
SUBROUTINE GET_PATCHWISE_BS(SF, INDX, PAR_PT, PATCHES, JACOB)
	INTEGER, INTENT(IN) :: PATCHES(2)
	TYPE(POINT2D), INTENT(IN) :: PAR_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB
	
	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(PATCHES(1), PATCHES(2), 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCHES(1), PATCHES(2), 2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(PATCHES(1), PATCHES(2), 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCHES(1), PATCHES(2), 2)%POLY_ORDER+1))
	
	TYPE(DIFF_BSPLINES) :: NX, NY
	TYPE(MATRIX_22) :: INV_JACOB
	TYPE(FUNCTION_1D) :: PUFT, ENRICH, T_TILT(2)
	TYPE(FUNCTION_2D) :: ENRICH2D
	TYPE(POINT2D) :: REF_PT, PHY_PT
	REAL*8 :: RADI, THETA
	
	INV_JACOB = .INVERSE.JACOB
	
!! ---------------------- [[[[[ COMPUTE BASIS FUNCTIONS ON THE PARAMETER SPACE (QUASI PHYSICAL SPACE) ]]]]] -----------------	
	T_TILT(1) = PARSP_TO_UNITSQ(PAR_PT%X, PATCHES, 'X')
	T_TILT(2) = PARSP_TO_UNITSQ(PAR_PT%Y, PATCHES, 'Y')
	
	IF (T_TILT(2)%VAL(0)<0.0D0 .OR. T_TILT(2)%VAL(0)>1.0D0) THEN
		
		NX%N(:,:) = 0.0D0
		NY%N(:,:) = 0.0D0
		GOTO 11
	ELSE
		NX = GET_ALL_DIFF_BSPLINES(T_TILT(1)%VAL(0), BASIS_KVEC(PATCHES(1), PATCHES(2), 1), 1)
		NY = GET_ALL_DIFF_BSPLINES(T_TILT(2)%VAL(0), BASIS_KVEC(PATCHES(1), PATCHES(2), 2), 1)

		DO I = 0, NX%POLY_ORDER
			NX%N(I,1) = NX%N(I,1)*T_TILT(1)%VAL(1)
		ENDDO
		
		DO J = 0, NY%POLY_ORDER
			NY%N(J,1) = NY%N(J,1)*T_TILT(2)%VAL(1)
		ENDDO
	ENDIF
! ---------------------------------------------------------------------------------------------------------------------------- 	

!! ----------------- [[[[[ COMPUTE PU W/ FLAT-TOP FUNCTIONS ON THE PARAMETER SPACE (QUASI PHYSICAL SPACE) ]]]]] --------------
	PUFT = PHYPU1D(PAR_PT%Y, PATCHES(2), 'Y')
! ---------------------------------------------------------------------------------------------------------------------------- 	

	13 CONTINUE
	
!! --------------------- [[[[[ COMPUTE PU*BASIS FUNCTIONS ON THE PHYSICAL SPACE ]]]]] ------------------------
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! OVERLAPPING REGION IN OMEGA_HAT1 & TOP OVERLAPPING REGION IN OMEGA_HAT2!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IF ((BETA - DELTA) <= PAR_PT%Y .AND. PAR_PT%Y < (BETA + DELTA)) THEN 
		IF (PATCHES(2)==1 .OR. PATCHES(2)==2) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! 					IF (PATCHES(2)==2 .AND. (NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! FLAT-TOP REGION IN OMEGA_HAT1!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSEIF ((BETA + DELTA) <= PAR_PT%Y .AND. PAR_PT%Y < 1.0D0) THEN 
		IF (PATCHES(2)==1) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
! 					INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! BOTTOM OVERLAPPING REGION IN OMEGA_HAT2 & TOP ONVERLAPPING REGION IN OMEGA_HAT3!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSEIF ((ALPHA - DELTA) < PAR_PT%Y .AND. PAR_PT%Y <= (ALPHA + DELTA)) THEN 
		IF (PATCHES(2)==2 .OR. PATCHES(2)==3) THEN
!--------------------------------- [[[[[ Enrichment functions ]]]]] -------------------------------------------------------------------
! 			ENRICH2D%VAL(0,0) = 1.0D0 - DEXP(DSIN(2.0D0*PI*PAR_PT%X)*PAR_PT%Y/EPSLN)
! 			ENRICH2D%VAL(1,0) = (-2.0D0*DEXP((PAR_PT%Y*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)*PI*PAR_PT%Y*DCOS(2.0D0*PI*PAR_PT%X))/EPSLN
! 			ENRICH2D%VAL(0,1) = -((DEXP((PAR_PT%Y*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)

! 			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN) - (1.0D0 - DEXP(-SIGMA/EPSLN))*(PAR_PT%Y/SIGMA)
! 			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN) - (1.0D0/SIGMA)*(1.0D0 - DEXP(-SIGMA/EPSLN))
			
			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN)
			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN)
			
!--------------------------------------------------------------------------------------------------------------------------------------
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
! 					IF (PDE=='CNVD' .AND. PROBLEM==4 .AND. PATCHES(2)==3 .AND. (NY%INIT+J)==0 .AND. (NX%INIT+I)>INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .AND. (NX%INIT+I)<LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
					IF (USE_ENRICH=='Y' .AND. PATCHES(2)==3 .AND. (NY%INIT+J)==0 .AND. ((NX%INIT+I)>=INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .OR. (NX%INIT+I)==0)) THEN
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*ENRICH%VAL(0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)

! 						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
! 						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
! 						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ELSE 
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ENDIF
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF 
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! FLAT-TOP REGION IN OMEGA_HAT2!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSEIF ((ALPHA + DELTA) <= PAR_PT%Y .AND. PAR_PT%Y < (BETA - DELTA)) THEN 
		IF (PATCHES(2)==2) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! FLAT-TOP REGION IN OMEGA_HAT3!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSEIF (0.0D0 <= PAR_PT%Y .AND. PAR_PT%Y <= (ALPHA - DELTA)) THEN 
		IF (PATCHES(2)==3) THEN
!--------------------------------- [[[[[ Enrichment functions ]]]]] -------------------------------------------------------------------
! 			ENRICH2D%VAL(0,0) = 1.0D0 - DEXP(DSIN(2.0D0*PI*PAR_PT%X)*PAR_PT%Y/EPSLN)
! 			ENRICH2D%VAL(1,0) = (-2.0D0*DEXP((PAR_PT%Y*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)*PI*PAR_PT%Y*DCOS(2.0D0*PI*PAR_PT%X))/EPSLN
! 			ENRICH2D%VAL(0,1) = -((DEXP((PAR_PT%Y*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)*DSIN(2.0D0*PI*PAR_PT%X))/EPSLN)

! 			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN) - (1.0D0 - DEXP(-SIGMA/EPSLN))*(PAR_PT%Y/SIGMA)
! 			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN) - (1.0D0/SIGMA)*(1.0D0 - DEXP(-SIGMA/EPSLN))
			
			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN)
			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN)
			
!--------------------------------------------------------------------------------------------------------------------------------------
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
! 					IF (PDE=='CNVD' .AND. PROBLEM==4 .AND. PATCHES(2)==3 .AND. (NY%INIT+J)==0 .AND. (NX%INIT+I)>=INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .AND. (NX%INIT+I)<LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
					IF (USE_ENRICH=='Y' .AND. PATCHES(2)==3 .AND. (NY%INIT+J)==0 .AND. ((NX%INIT+I)>=INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .OR. (NX%INIT+I)==0)) THEN
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*ENRICH%VAL(0)
						SF(K)%D10 = NX%N(I,1)*ENRICH%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*ENRICH%VAL(1)*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*ENRICH%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*ENRICH%VAL(1)*INV_JACOB%ENT(2,2)
						
! 						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
! 						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
! 						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
					ELSE 
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
					ENDIF
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF 		
	ENDIF
	
	11 CONTINUE
	SF(:)%D00 = 0.0D0
	SF(:)%D10 = 0.0D0
	SF(:)%D01 = 0.0D0
	
	12 CONTINUE
! ---------------------------------------------------------------------------------------------------------------------------- 	
END SUBROUTINE GET_PATCHWISE_BS

!! ----------------------------- [[[[[ MODIFIED B-SPLINE BASIS FUNCTIONS FOR APPROXIMATION]]]]] ----------------------------- 
!-----------------------------------------------------------------------------------------------------------
SUBROUTINE GET_APPROX_BS(SF, INDX, PAR_PT, PATCHES, JACOB)
	INTEGER, INTENT(IN) :: PATCHES(2)
	TYPE(POINT2D), INTENT(IN) :: PAR_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB
	
	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(PATCHES(1), PATCHES(2), 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCHES(1), PATCHES(2), 2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(PATCHES(1), PATCHES(2), 1)%POLY_ORDER+1)*(BASIS_KVEC(PATCHES(1), PATCHES(2), 2)%POLY_ORDER+1))
	
	TYPE(DIFF_BSPLINES) :: NX, NY
	TYPE(MATRIX_22) :: INV_JACOB
	TYPE(FUNCTION_1D) :: PUFT, ENRICH, T_TILT(2)
	TYPE(POINT2D) :: REF_PT, PHY_PT
	REAL*8 :: RADI, THETA
	
	INV_JACOB = .INVERSE.JACOB
	
!! ---------------------- [[[[[ COMPUTE BASIS FUNCTIONS ON THE PARAMETER SPACE (QUASI PHYSICAL SPACE) ]]]]] -----------------	
	T_TILT(1) = PARSP_TO_UNITSQ(PAR_PT%X, PATCHES, 'X')
	T_TILT(2) = PARSP_TO_UNITSQ(PAR_PT%Y, PATCHES, 'Y')
	
	IF (T_TILT(2)%VAL(0)<0.0D0 .OR. T_TILT(2)%VAL(0)>1.0D0) THEN
		NX%N(:,:) = 0.0D0
		NY%N(:,:) = 0.0D0
		GOTO 11
	ELSE
		NX = GET_ALL_DIFF_BSPLINES(T_TILT(1)%VAL(0), BASIS_KVEC(PATCHES(1), PATCHES(2), 1), 1)
		NY = GET_ALL_DIFF_BSPLINES(T_TILT(2)%VAL(0), BASIS_KVEC(PATCHES(1), PATCHES(2), 2), 1)

		DO I = 0, NX%POLY_ORDER
			NX%N(I,1) = NX%N(I,1)*T_TILT(1)%VAL(1)
		ENDDO
		
		DO J = 0, NY%POLY_ORDER
			NY%N(J,1) = NY%N(J,1)*T_TILT(2)%VAL(1)
		ENDDO
	ENDIF
! ---------------------------------------------------------------------------------------------------------------------------- 	

!! ----------------- [[[[[ COMPUTE PU W/ FLAT-TOP FUNCTIONS ON THE PARAMETER SPACE (QUASI PHYSICAL SPACE) ]]]]] --------------
	PUFT = PHYPU1D(PAR_PT%Y, PATCHES(2), 'Y')
! ---------------------------------------------------------------------------------------------------------------------------- 	

	13 CONTINUE
	
!! --------------------- [[[[[ COMPUTE PU*BASIS FUNCTIONS ON THE PHYSICAL SPACE ]]]]] ------------------------
	IF ((BETA - DELTA) < PAR_PT%Y .AND. PAR_PT%Y < (BETA + DELTA)) THEN ! OVERLAPPING REGION IN OMEGA_HAT1 & TOP OVERLAPPING REGION IN OMEGA_HAT2
		IF (PATCHES(2)==1 .OR. PATCHES(2)==2) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! 					IF (PATCHES(2)==2 .AND. (NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	ELSEIF ((BETA + DELTA) < PAR_PT%Y .AND. PAR_PT%Y < 1.0D0) THEN ! FLAT-TOP REGION IN OMEGA_HAT1
		IF (PATCHES(2)==1) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! 					INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	ELSEIF ((ALPHA - DELTA) < PAR_PT%Y .AND. PAR_PT%Y < (ALPHA + DELTA)) THEN ! BOTTOM OVERLAPPING REGION IN OMEGA_HAT2 & TOP ONVERLAPPING REGION IN OMEGA_HAT3
		IF (PATCHES(2)==2 .OR. PATCHES(2)==3) THEN
			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN)
			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN)
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					IF (PATCHES(2)==3 .AND. (NX%INIT+I)>=INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .AND. (NX%INIT+I)<LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*ENRICH%VAL(0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! 						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
! 						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
! 						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ELSE 
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ENDIF
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF 
	ELSEIF ((ALPHA + DELTA) < PAR_PT%Y .AND. PAR_PT%Y < (BETA - DELTA)) THEN ! FLAT-TOP REGION IN OMEGA_HAT2
		IF (PATCHES(2)==2) THEN
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					K = K + 1
					SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
					SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
					SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF
	ELSEIF (0.0D0 < PAR_PT%Y .AND. PAR_PT%Y < (ALPHA - DELTA)) THEN ! FLAT-TOP REGION IN OMEGA_HAT3
		IF (PATCHES(2)==3) THEN
			ENRICH%VAL(0) = 1.0D0 - DEXP(-PAR_PT%Y/EPSLN)
			ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-PAR_PT%Y/EPSLN)
			K = 0
			DO J=0, NY%POLY_ORDER
				DO I=0, NX%POLY_ORDER
					IF ((NX%INIT+I)>=INT(0.5*(LOC_NUMBS(PATCHES(1), PATCHES(2), 1)-1)) .AND. (NX%INIT+I)<LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*ENRICH%VAL(0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! 						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
! 						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
! 						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ELSE 
						K = K + 1
						SF(K)%D00 = NX%N(I,0)*NY%N(J,0)*PUFT%VAL(0)
						SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
						SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(NY%N(J,1)*PUFT%VAL(0) + NY%N(J,0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
					ENDIF
					IF ((NX%INIT+I)==LOC_NUMBS(PATCHES(1), PATCHES(2), 1)) THEN ! LOC_NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
						INDX(K) = INT2D(0, NY%INIT+J)
					ELSE 
						INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
					ENDIF
				ENDDO
			ENDDO
			GOTO 12
		ELSE 
			GOTO 11
		ENDIF 		
	ENDIF
	
	11 CONTINUE
	SF(:)%D00 = 0.0D0
	SF(:)%D10 = 0.0D0
	SF(:)%D01 = 0.0D0
	
	12 CONTINUE
! ---------------------------------------------------------------------------------------------------------------------------- 	
END SUBROUTINE GET_APPROX_BS


! !! ----------------------------- [[[[[ MODIFIED B-SPLINE BASIS FUNCTIONS ]]]]] ----------------------------- 
! !! SATISFY THE PERIODIC CONDITION
! !! BUILT IN ENRICHMENT BASIS FUNCTIONS
! !-----------------------------------------------------------------------------------------------------------
! !! FIND ALL NONVANISHING BASIS FUNCTION ON PHYSICAL SPACE
! SUBROUTINE GET_ALL_PHY_BASIS_IN_INT(SF, INDX, REF_PT, JACOB)
! 	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(POINT2D), INTENT(IN) :: REF_PT
! 	TYPE(MATRIX_22), INTENT(IN) :: JACOB
! 
! 	TYPE(DIFF_BSPLINES) :: NX, NY
! 	TYPE(MATRIX_22) :: INV_JACOB
! 	TYPE(FUNCTION_1D) :: PUFT, ENRICH
! 	
! 	INV_JACOB = .INVERSE.JACOB
! 	
! 	NX = GET_ALL_DIFF_BSPLINES(REF_PT%X, BASIS_KVEC(1), 1)
! 	NY = GET_ALL_DIFF_BSPLINES(REF_PT%Y, BASIS_KVEC(2), 1)
! 	
! ! 	PUFT = PHYPU1D(REF_PT%Y, 1, 'Y')
! ! 	ENRICH%VAL(0) = 1.0D0 - DEXP(-REF_PT%Y/EPSLN)
! ! 	ENRICH%VAL(1) = (1.0D0/EPSLN)*DEXP(-REF_PT%Y/EPSLN)
! 	
! 	K = 0
! 	DO J=0, NY%POLY_ORDER
! 		DO I=0, NX%POLY_ORDER
! 			K = K + 1
! 			SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
! 			SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
! 			SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
! 			
! 			IF ((NX%INIT+I)==NUMBS(1)) THEN ! NUMBS(1) = BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1
! 				INDX(K) = INT2D(0, NY%INIT+J)
! ! 			ELSEIF ((NX%INIT+I)>=NUMBS(1) - BS_ORDER(1) .AND. (NX%INIT+I)<NUMBS(1)) THEN
! ! 				PUFT = PHYPU1D(REF_PT%Y, 1, 'Y')
! ! 				SF(K)%D00 = NX%N(I,0)*ENRICH%VAL(0)*PUFT%VAL(0)
! ! 				SF(K)%D10 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,1)
! ! 				SF(K)%D01 = NX%N(I,1)*ENRICH%VAL(0)*PUFT%VAL(0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*(ENRICH%VAL(1)*PUFT%VAL(0) + ENRICH%VAL(0)*PUFT%VAL(1))*INV_JACOB%ENT(2,2)
! ! 				INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
! 			ELSE
! 				INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
! 			ENDIF
! 		ENDDO
! 	ENDDO
! ! 	PRINT*, INDX(1),SF(1)
! ! 	STOP
! END SUBROUTINE GET_ALL_PHY_BASIS_IN_INT
! 
! !! FIND ALL NONVANISHING BASIS FUNCTION ON PHYSICAL SPACE
! SUBROUTINE GET_ALL_PHY_BASIS(SF, INDX, REF_PT)
! 	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(POINT2D), INTENT(IN) :: REF_PT
! 
! 	TYPE(DIFF_BSPLINES) :: NX, NY
! 	TYPE(MATRIX_22) :: INV_JACOB, JACOB
! 	
! 	JACOB = GET_JACOBIAN_MATRIX(REF_PT)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
! 	INV_JACOB = .INVERSE.JACOB
! 	
! 	NX = GET_ALL_DIFF_BSPLINES(REF_PT%X, BASIS_KVEC(1), 1)
! 	NY = GET_ALL_DIFF_BSPLINES(REF_PT%Y, BASIS_KVEC(2), 1)
! 
! 	K = 0
! 	DO J=0, NY%POLY_ORDER
! 		DO I=0, NX%POLY_ORDER
! 			K = K + 1
! 			SF(K)%D00 = NX%N(I,0)*NY%N(J,0)
! 			SF(K)%D10 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,1) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,1)
! 			SF(K)%D01 = NX%N(I,1)*NY%N(J,0)*INV_JACOB%ENT(1,2) + NX%N(I,0)*NY%N(J,1)*INV_JACOB%ENT(2,2)
! 			IF ((NX%INIT+I)==(BASIS_KVEC(1)%LENGTH - BS_ORDER(1)-1)) THEN
! 				INDX(K) = INT2D(0, NY%INIT+J)
! 			ELSE
! 				INDX(K) = INT2D(NX%INIT+I, NY%INIT+J)
! 			ENDIF
! 		ENDDO
! 	ENDDO
! 
! END SUBROUTINE GET_ALL_PHY_BASIS
! 
! 
! 
! 
! 
! 
! !! ---------------------------- [[[[[ NURBS BASIS FUNCTION ]]]]] ---------------------------- 
! !--------------------------------------------------------------------------------------------------------------
! !!  FIND DERIVATIVES OF NURBS SURFACE ON TWO-DIMENSIONAL SPACE
! !!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
! !!  OUTPUT : DERIVATIVES OF NURBS SURFACE
! SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D(SF, INDX, REF_PT, JACOB)
! 
! 	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
! 	TYPE(POINT2D), INTENT(IN) :: REF_PT
! 	TYPE(MATRIX_22), INTENT(IN) :: JACOB
! 
! 	TYPE(MATRIX_22) :: INV_JACOB, JACOBIAN
! 	TYPE(FUNCTION_2D) :: DIFF_NURBS
! 	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
! 	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
! 	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
! 	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX
! 
! 	DIFF_ORDER = 1
! 
! 	INV_JACOB = .INVERSE.JACOB					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)
! 
! ! 	ELSE
! ! 		JACOBIAN = GET_JACOBIAN_MATRIX(REF_PT,PATCH)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
! ! 		INV_JACOB = .INVERSE.JACOBIAN					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)
! ! 	ENDIF
! 	
! 	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(1),DIFF_ORDER)
! 	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(2),DIFF_ORDER)
! 
! 	
! 	DO K = 0, DIFF_ORDER
! 	DO L = 0, DIFF_ORDER-K
! 		DWSUM(K,L) = 0.0D0
! 		DO J1 = 0, BASIS_KVEC(1)%POLY_ORDER
! 			INDX_X = DBSFUN(1)%INIT + J1
! 			IF (INDX_X>=0) THEN
! 				DO J2 = 0, BASIS_KVEC(2)%POLY_ORDER
! 					INDX_Y = DBSFUN(2)%INIT + J2
! 					IF (INDX_Y>=0) THEN
! 						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
! 					ENDIF
! 				ENDDO
! 			ENDIF
! 		ENDDO
! 	ENDDO
! 	ENDDO
! 
! 	LC_INDX = 0
! 	
! 	DO I1 = 0, BASIS_KVEC(1)%POLY_ORDER
! 		
! 		INDX_X = DBSFUN(1)%INIT + I1
! 
! 	DO I2 = 0, BASIS_KVEC(2)%POLY_ORDER
! 		
! 		INDX_Y = DBSFUN(2)%INIT + I2
! 		LC_INDX = LC_INDX + 1
! 		INDX(LC_INDX) = INT2D(INDX_X, INDX_Y)
! 		
! 		DO K = 0, DIFF_ORDER
! 		DO L = 0, DIFF_ORDER-K
! 		
! 			DIFF_NURBS%VAL(K,L) = DBSFUN(1)%N(I1,K)*DBSFUN(2)%N(I2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
! 			
! 			DO J1 = 1, K
! 				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
! 			ENDDO
! 			DO J2 = 1, L
! 				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
! 			ENDDO
! 			DO J1 = 1, K
! 			DO J2 = 1, L
! 				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
! 			ENDDO
! 			ENDDO
! 			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)
! 		ENDDO
! 		ENDDO
! 		
! 		SF(LC_INDX)%D00 = DIFF_NURBS%VAL(0,0)
! 		SF(LC_INDX)%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
! 		SF(LC_INDX)%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
! 		
! 	ENDDO
! 	ENDDO
! 
! END SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D
! 
! 
! TYPE(FVALUE) FUNCTION GET_PHY_NURBS_SURFACE_2D(REF_PT, IX, IY, JACOB)
! 
! 	INTEGER, INTENT(IN) :: IX, IY
! 	TYPE(POINT2D), INTENT(IN) :: REF_PT
! 	TYPE(MATRIX_22), INTENT(IN) :: JACOB
! 
! 	TYPE(MATRIX_22) :: INV_JACOB
! 	TYPE(FUNCTION_2D) :: REF_SF, DIFF_NURBS
! 	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
! 	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
! 	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
! 	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX
! 
! 	DIFF_ORDER = 1
! 
! 	INV_JACOB = .INVERSE.JACOB
! 	
! 	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(1),DIFF_ORDER)
! 	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(2),DIFF_ORDER)
! 
! 	DO K = 0, DIFF_ORDER
! 	DO L = 0, DIFF_ORDER-K
! 		DWSUM(K,L) = 0.0D0
! 		DO J1 = 0, BASIS_KVEC(1)%POLY_ORDER
! 			INDX_X = DBSFUN(1)%INIT + J1
! 			IF (INDX_X>=0) THEN
! 				DO J2 = 0, BASIS_KVEC(2)%POLY_ORDER
! 					INDX_Y = DBSFUN(2)%INIT + J2
! 					IF (INDX_Y>=0) THEN
! 						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
! 					ENDIF
! 				ENDDO
! 			ENDIF
! 		ENDDO
! 	ENDDO
! 	ENDDO
! 
! 	REF_SF = GET_BASIS(REF_PT,(/IX,IY/))
! 		
! 	DO K = 0, DIFF_ORDER
! 	DO L = 0, DIFF_ORDER-K
! 	
! 		DIFF_NURBS%VAL(K,L) = REF_SF%VAL(K,L)*BASIS_CTL%WGTS(IX,IY,0)
! 		
! 		DO J1 = 1, K
! 			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
! 		ENDDO
! 		DO J2 = 1, L
! 			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
! 		ENDDO
! 		DO J1 = 1, K
! 		DO J2 = 1, L
! 			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
! 		ENDDO
! 		ENDDO
! 
! 		DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)
! 
! 	ENDDO
! 	ENDDO
! 	
! 	GET_PHY_NURBS_SURFACE_2D%D00 = DIFF_NURBS%VAL(0,0)
! 	GET_PHY_NURBS_SURFACE_2D%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
! 	GET_PHY_NURBS_SURFACE_2D%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
! 		
! END FUNCTION GET_PHY_NURBS_SURFACE_2D
! 
! !!  FIND BASIS FUNCTION ON PARAMETRIC SPACE
! TYPE(FUNCTION_2D) FUNCTION GET_BASIS(REF_PT,INDX)
! 
! 	TYPE(POINT2D), INTENT(IN) :: REF_PT
! 	INTEGER, INTENT(IN) :: INDX(2)
! 
! 	TYPE(FUNCTION_1D) :: NX, NY
! 
! 	NX = GET_DIFF_BSPLINE(REF_PT%X,BASIS_KVEC(1),INDX(1),1)
! 	NY = GET_DIFF_BSPLINE(REF_PT%Y,BASIS_KVEC(2),INDX(2),1)
! 
! 	GET_BASIS%VAL(0,0) = NX%VAL(0) * NY%VAL(0)
! 	GET_BASIS%VAL(1,0) = NX%VAL(1) * NY%VAL(0)
! 	GET_BASIS%VAL(0,1) = NX%VAL(0) * NY%VAL(1)
! ! 	GET_BASIS%VAL(2,0) = NX%VAL(2) * NY%VAL(0)
! ! 	GET_BASIS%VAL(1,1) = NX%VAL(1) * NY%VAL(1)
! ! 	GET_BASIS%VAL(0,2) = NX%VAL(0) * NY%VAL(2)
! 
! END FUNCTION GET_BASIS

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! ---------------- [[[[[ NURBS PU WITH FLAT-TOP ]]]]] ----------------

! TYPE(FUNCTION_1D) FUNCTION GET_BSPLINEPU1D(PHYX, PATCH)
! 
! 	REAL*8, INTENT(IN) :: PHYX
! 	INTEGER, INTENT(IN) :: PATCH
! 	
! 	TYPE(FUNCTION_1D) :: NX, REFX
! 	INTEGER :: I, J, K
! 	
! 	REFX%VAL(0) = PHYX
! 	
! 	GET_BSPLINEPU1D%VAL(:) = 0.0D0
! 	
! 	DO I = 0, 2*PU_KVEC%POLY_ORDER - 3
! 		NX = GET_DIFF_BSPLINE(REFX%VAL(0), PU_KVEC, I + (PATCH-1)*(2*PU_KVEC%POLY_ORDER - 2), 2)
! 		GET_BSPLINEPU1D = GET_BSPLINEPU1D + NX
! 		NX%VAL(:) = 0.0D0
! 	ENDDO
! 	
! ! 	IF (DABS(REFX%VAL(0) - COL_PT(4))<=EPS) THEN
! ! 		PRINT*, GET_BSPLINEPU1D%VAL(:)
! ! 	ENDIF
! 	
! END FUNCTION GET_BSPLINEPU1D

!--------------------------PHYSICAL PU-1D-----------------------------

TYPE(FUNCTION_1D) FUNCTION PHYPU1D(PHYX, PATCH, AXIS)

    REAL*8, INTENT(IN) :: PHYX	
    INTEGER, INTENT(IN) :: PATCH
    CHARACTER(LEN=1), INTENT(IN) :: AXIS
    
    TYPE(FUNCTION_1D) :: PUMAP

    PUMAP = PATCH_TO_REFPU(PHYX, PATCH, AXIS)
		
		PHYPU1D%VAL(0) = PU1D(PUMAP%VAL(0), 0)
		PHYPU1D%VAL(1) = PU1D(PUMAP%VAL(0), 1)*PUMAP%VAL(1)

END FUNCTION PHYPU1D

REAL*8 FUNCTION PU1D(X, FLAGX)

	REAL*8, INTENT(IN) :: X
	INTEGER, INTENT(IN) :: FLAGX

	IF (FLAGX.EQ. 0) THEN													! PU-FUNCTION
		IF ((X + 1.0D0 .GE. EPS) .AND. (X .LT. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=(1.0D0+X)
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=((1.0D0+X)**2)*(1.0D0-2.0D0*X)
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=((1.0D0+X)**3)*(1.0D0-3.0D0*X+6.0D0*X**2)
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=((1.0D0+X)**4)*(1.0D0-4.0D0*X+10.0D0*X**2-20.0D0*X**3)
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=((1.0D0+X)**5)*(1.0D0-5.0D0*X+15.0D0*X**2-35.0D0*X**3+70.0D0*X**4)
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=((1.0D0+X)**6.0D0)*(1.0D0-6.0D0*X+21.0D0*X**2.0D0-56.0D0*X**3.0D0+126.0D0*X**4.0D0 &
				-252.0D0*X**5.0D0)
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=((1.0D0+X)**7)*(1.0D0-7.0D0*X+28.0D0*X**2-84.0D0*X**3+210.0D0*X**4-462.0D0*X**5 &
				+924.0D0*X**6)
			ENDIF
		ELSEIF ((X .GE. EPS) .AND. (X - 1.0D0 .LT. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=(1.0D0-X)
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=((1.0D0-X)**2)*(1.0D0+2.0D0*X)
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=((1.0D0-X)**3)*(1.0D0+3.0D0*X+6.0D0*X**2)
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=((1.0D0-X)**4)*(1.0D0+4.0D0*X+10.0D0*X**2+20.0D0*X**3)
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=((1.0D0-X)**5)*(1.0D0+5.0D0*X+15.0D0*X**2.0D0+35.0D0*X**3.0D0+70.0D0*X**4)
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=((1.0D0-X)**6)*(1.0D0+6.0D0*X+21.0D0*X**2+56.0D0*X**3+126.0D0*X**4+252.0D0*X**5)
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=((1.0D0-X)**7)*(1.0D0+7.0D0*X+28.0D0*X**2+84.0D0*X**3+210.0D0*X**4+462.0D0*X**5 &
				+924.0D0*X**6)
			ENDIF
		ELSE
			PU1D=0.0D0
		ENDIF
	ELSEIF (FLAGX.EQ.1) THEN												! DIFFERENTIATION OF PU-FUNCTION
		IF ((X + 1.0D0 .GE. EPS) .AND. (X .LT. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=1.0D0
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=-6.0D0*X*(1.0D0 + X)
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=30.0D0*X**2*(1.0D0 + X)**2
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=-140.0D0*X**3*(1.0D0 + X)**3
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=630.0D0*X**4*(1.0D0 + X)**4
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=-2772.0D0*X**5*(1.0D0 + X)**5
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=12012.0D0*X**6*(1.0D0 + X)**6
			ENDIF
		ELSEIF ((X .GT. EPS) .AND. (X - 1.0D0 .LE. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=-1.0D0
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=6.0D0*(-1.0D0 + X)*X
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=-30.0D0*(-1.0D0 + X)**2*X**2
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=140.0D0*(-1.0D0 + X)**3*X**3
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=-630.0D0*(-1.0D0 + X)**4*X**4
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=2772.0D0*(-1.0D0 + X)**5*X**5
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=-12012.0D0*(-1.0D0 + X)**6*X**6
			ENDIF
        ELSE
            PU1D=0.0D0
		ENDIF
	ELSEIF (FLAGX.EQ.2) THEN												! DIFFERENTIATION OF PU-FUNCTION
		IF ((X + 1.0D0 .GE. EPS) .AND. (X .LT. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=0.0D0
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=-6*x - 6*(1.0D0 + x)
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=60*x**2*(1.0D0 + X) + 60*x*(1.0D0 + X)**2
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=-420*x**3*(1.0D0 + X)**2 - 420*x**2*(1.0D0 + X)**3
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=2520*x**4*(1.0D0 + X)**3 + 2520*x**3*(1.0D0 + X)**4
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=-13860*x**5*(1.0D0 + X)**4 - 13860*x**4*(1.0D0 + X)**5
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=72072*x**6*(1.0D0 + X)**5 + 72072*x**5*(1.0D0 + X)**6
			ENDIF
		ELSEIF ((X .GT. EPS) .AND. (X - 1.0D0 .LE. EPS)) THEN
			IF (PUORDER.EQ.1) THEN
				PU1D=0.0D0
			ELSEIF (PUORDER.EQ.2) THEN
				PU1D=6*x + 6*(-1.0D0 + X)
			ELSEIF (PUORDER.EQ.3) THEN
				PU1D=-60*x**2*(-1.0D0 + X) - 60*x*(-1.0D0 + X)**2
			ELSEIF (PUORDER.EQ.4) THEN
				PU1D=420*x**3*(-1.0D0 + X)**2 + 420*x**2*(-1.0D0 + X)**3
			ELSEIF (PUORDER.EQ.5) THEN
				PU1D=-2520*x**4*(-1.0D0 + X)**3 - 2520*x**3*(-1.0D0 + X)**4
			ELSEIF (PUORDER.EQ.6) THEN
				PU1D=13860*x**5*(-1.0D0 + X)**4 + 13860*x**4*(-1.0D0 + X)**5
			ELSEIF (PUORDER.EQ.7) THEN
				PU1D=-72072*x**6*(-1.0D0 + X)**5 - 72072*x**5*(-1.0D0 + X)**6
			ENDIF
        ELSE
            PU1D=0.0D0
		ENDIF
		IF (DABS(X).LE.EPS) THEN
            PU1D=0.0D0
        ENDIF
	ENDIF
END FUNCTION PU1D

END MODULE NURBS_BASIS