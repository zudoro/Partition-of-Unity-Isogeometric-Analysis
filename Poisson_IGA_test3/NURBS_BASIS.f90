MODULE NURBS_BASIS

	USE GLBVAR
	USE PATCH_MAPPING

	IMPLICIT INTEGER (I-N)
	IMPLICIT REAL(8) (A-H,O-Z)

CONTAINS

!!  GET BASIS FUNCTION ON PHYSICAL SPACE


!!  FIND DERIVATIVES OF NURBS SURFACE ON TWO-DIMENSIONAL SPACE
!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
!!  OUTPUT : DERIVATIVES OF NURBS SURFACE
SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D(SF, INDX, REF_PT, JACOB)

	TYPE(FVALUE), INTENT(OUT) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	TYPE(INT2D), INTENT(OUT) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB

	TYPE(MATRIX_22) :: INV_JACOB, JACOBIAN
	TYPE(FUNCTION_2D) :: DIFF_NURBS
	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX

	DIFF_ORDER = 1

	INV_JACOB = .INVERSE.JACOB					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)

! 	ELSE
! 		JACOBIAN = GET_JACOBIAN_MATRIX(REF_PT,PATCH)			!! P(X)/P(XI), P(X)/P(ETA) // P(Y)/P(XI), P(Y)/P(ETA)
! 		INV_JACOB = .INVERSE.JACOBIAN					!! P(XI)/P(X), P(XI)/P(Y) // P(ETA)/P(X), P(ETA)/P(Y)
! 	ENDIF
	
	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(1),DIFF_ORDER)
	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(2),DIFF_ORDER)

	
	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
		DWSUM(K,L) = 0.0D0
		DO J1 = 0, BASIS_KVEC(1)%POLY_ORDER
			INDX_X = DBSFUN(1)%INIT + J1
			IF (INDX_X>=0) THEN
				DO J2 = 0, BASIS_KVEC(2)%POLY_ORDER
					INDX_Y = DBSFUN(2)%INIT + J2
					IF (INDX_Y>=0) THEN
						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
					ENDIF
				ENDDO
			ENDIF
		ENDDO
	ENDDO
	ENDDO

	LC_INDX = 0
	
	DO I1 = 0, BASIS_KVEC(1)%POLY_ORDER
		
		INDX_X = DBSFUN(1)%INIT + I1

	DO I2 = 0, BASIS_KVEC(2)%POLY_ORDER
		
		INDX_Y = DBSFUN(2)%INIT + I2
		LC_INDX = LC_INDX + 1
		INDX(LC_INDX) = INT2D(INDX_X, INDX_Y)
		
		DO K = 0, DIFF_ORDER
		DO L = 0, DIFF_ORDER-K
		
			DIFF_NURBS%VAL(K,L) = DBSFUN(1)%N(I1,K)*DBSFUN(2)%N(I2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
			
			DO J1 = 1, K
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
			ENDDO
			DO J2 = 1, L
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
			ENDDO
			DO J1 = 1, K
			DO J2 = 1, L
				DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
			ENDDO
			ENDDO
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)
		ENDDO
		ENDDO
		
		SF(LC_INDX)%D00 = DIFF_NURBS%VAL(0,0)
		SF(LC_INDX)%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
		SF(LC_INDX)%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
		
	ENDDO
	ENDDO

END SUBROUTINE GET_ALL_PHY_NURBS_SURFACE_2D


TYPE(FVALUE) FUNCTION GET_PHY_NURBS_SURFACE_2D(REF_PT, IX, IY, JACOB)

	INTEGER, INTENT(IN) :: IX, IY
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	TYPE(MATRIX_22), INTENT(IN) :: JACOB

	TYPE(MATRIX_22) :: INV_JACOB
	TYPE(FUNCTION_2D) :: REF_SF, DIFF_NURBS
	TYPE(DIFF_BSPLINES) :: DBSFUN(2)
	REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
	INTEGER :: INDX_X, INDX_Y, DIFF_ORDER
	INTEGER :: I, J, K, L, J1, J2, I1, I2, LC_INDX

	DIFF_ORDER = 1

	INV_JACOB = .INVERSE.JACOB
	
	DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(REF_PT%X,BASIS_KVEC(1),DIFF_ORDER)
	DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(REF_PT%Y,BASIS_KVEC(2),DIFF_ORDER)

	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
		DWSUM(K,L) = 0.0D0
		DO J1 = 0, BASIS_KVEC(1)%POLY_ORDER
			INDX_X = DBSFUN(1)%INIT + J1
			IF (INDX_X>=0) THEN
				DO J2 = 0, BASIS_KVEC(2)%POLY_ORDER
					INDX_Y = DBSFUN(2)%INIT + J2
					IF (INDX_Y>=0) THEN
						DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*BASIS_CTL%WGTS(INDX_X,INDX_Y,0)
					ENDIF
				ENDDO
			ENDIF
		ENDDO
	ENDDO
	ENDDO

	REF_SF = GET_BASIS(REF_PT,(/IX,IY/))
		
	DO K = 0, DIFF_ORDER
	DO L = 0, DIFF_ORDER-K
	
		DIFF_NURBS%VAL(K,L) = REF_SF%VAL(K,L)*BASIS_CTL%WGTS(IX,IY,0)
		
		DO J1 = 1, K
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS%VAL(K-J1,L)
		ENDDO
		DO J2 = 1, L
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS%VAL(K,L-J2)
		ENDDO
		DO J1 = 1, K
		DO J2 = 1, L
			DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS%VAL(K-J1,L-J2)
		ENDDO
		ENDDO

		DIFF_NURBS%VAL(K,L) = DIFF_NURBS%VAL(K,L) / DWSUM(0,0)

	ENDDO
	ENDDO
	
	GET_PHY_NURBS_SURFACE_2D%D00 = DIFF_NURBS%VAL(0,0)
	GET_PHY_NURBS_SURFACE_2D%D10 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,1) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,1)
	GET_PHY_NURBS_SURFACE_2D%D01 = DIFF_NURBS%VAL(1,0)*INV_JACOB%ENT(1,2) + DIFF_NURBS%VAL(0,1)*INV_JACOB%ENT(2,2)
		
END FUNCTION GET_PHY_NURBS_SURFACE_2D

!!  FIND BASIS FUNCTION ON PARAMETRIC SPACE
TYPE(FUNCTION_2D) FUNCTION GET_BASIS(REF_PT,INDX)

	TYPE(POINT2D), INTENT(IN) :: REF_PT
	INTEGER, INTENT(IN) :: INDX(2)

	TYPE(FUNCTION_1D) :: NX, NY

	NX = GET_DIFF_BSPLINE(REF_PT%X,BASIS_KVEC(1),INDX(1),1)
	NY = GET_DIFF_BSPLINE(REF_PT%Y,BASIS_KVEC(2),INDX(2),1)

	GET_BASIS%VAL(0,0) = NX%VAL(0) * NY%VAL(0)
	GET_BASIS%VAL(1,0) = NX%VAL(1) * NY%VAL(0)
	GET_BASIS%VAL(0,1) = NX%VAL(0) * NY%VAL(1)
! 	GET_BASIS%VAL(2,0) = NX%VAL(2) * NY%VAL(0)
! 	GET_BASIS%VAL(1,1) = NX%VAL(1) * NY%VAL(1)
! 	GET_BASIS%VAL(0,2) = NX%VAL(0) * NY%VAL(2)

END FUNCTION GET_BASIS

END MODULE NURBS_BASIS