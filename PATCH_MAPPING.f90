MODULE PATCH_MAPPING

	USE NURBS

	implicit integer (i-n)
	implicit real(8) (a-h,o-z)

CONTAINS

	!!  GET THE CORRESPONDING POINT ON THE PHYSICAL SPACE OF GIVE POINT ON THE PARAMETRIC SPACE
	TYPE(POINT2D) FUNCTION GET_PHY_PT(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: PATCH

		GET_PHY_PT = GET_POINT_NURVE_SURFACE_2D(REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))

! 		IF (PRESENT(PATCH)) THEN
! 			IF (PATCH.EQ.1) THEN
! 				GET_PHY_PT = GET_POINT_NURVE_SURFACE_2D(REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))
! 			ELSE
! 				GET_PHY_PT = GET_POINT_NURVE_SURFACE_2D(REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))
! 			ENDIF
! 		ELSE
! 			GET_PHY_PT = GET_POINT_NURVE_SURFACE_2D(REF_PT,GEO_KVEC(1,:),GEO_CTL(1))
! 		ENDIF

	END FUNCTION GET_PHY_PT


	!!  GET THE CORRESPONDING POINT ON THE PARAMETRIC SPACE OF GIVE POINT ON THE PHYSICAL SPACE
	TYPE(POINT2D) FUNCTION GET_REF_PT(PHY_PT, PATCH, SIDE)

		TYPE(POINT2D), INTENT(IN) :: PHY_PT
		INTEGER, INTENT(IN) :: PATCH
		CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: SIDE

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
		TYPE(POINT2D) :: NEW_PT, OLD_PT, TMP_PT
		REAL(8) :: ERROR, INV_J, R, THETA
		INTEGER :: ITER, K(2), INDX_SUPP

		ERROR = 1.0D0
		

		OLD_PT = GOOD_INITIAL(PHY_PT, PATCH)
		
! 		OLD_PT%X = 0.5D0
! 		OLD_PT%Y = 0.5D0

		ITER = 0
		K(:) = 0
		DO WHILE (ERROR>TOLERANCE)
			ITER = ITER + 1
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

			TMP_PT%X = DIFF_NURBS(1)%VAL(0,0)-PHY_PT%X
			TMP_PT%Y = DIFF_NURBS(2)%VAL(0,0)-PHY_PT%Y

			ERROR = MAX(DABS(TMP_PT%X),DABS(TMP_PT%Y))
			
			IF (ERROR<TOLERANCE .AND. OLD_PT%X.GE.0.D0 .AND. OLD_PT%X.LE.1.D0 .AND. OLD_PT%Y.GE.0.D0 .AND. OLD_PT%Y.LE.1.D0) THEN
				GET_REF_PT = OLD_PT
				GOTO 999
			ELSE
				INV_J = 1.0D0 / (DIFF_NURBS(1)%VAL(1,0)*DIFF_NURBS(2)%VAL(0,1)-DIFF_NURBS(1)%VAL(0,1)*DIFF_NURBS(2)%VAL(1,0))
				NEW_PT%X = OLD_PT%X - INV_J*(DIFF_NURBS(2)%VAL(0,1)*TMP_PT%X-DIFF_NURBS(1)%VAL(0,1)*TMP_PT%Y)
				NEW_PT%Y = OLD_PT%Y - INV_J*(DIFF_NURBS(1)%VAL(1,0)*TMP_PT%Y-DIFF_NURBS(2)%VAL(1,0)*TMP_PT%X)
				OLD_PT = NEW_PT
				
! 				PRINT*, PHY_PT, OLD_PT
! 				PRINT*, 'GET_REF_PT-HERE2'

! 				IF (OLD_PT%X.LE.0.D0 .OR. OLD_PT%X.GE.1.D0) THEN
! 					K(1) = K(1) + 1
! 					IF (PATCH.LE.NUM_PATCH) THEN
! 						OLD_PT%X = 0.0001D0*K(1)
! 					ELSE
! 						OLD_PT%X = (INDX_SUPP-1)*0.25D0 + INDX_SUPP*0.00025D0*K(1)
! 					ENDIF
! 					ITER = 0
! 				ENDIF
! 				IF (OLD_PT%Y.LE.0.D0 .OR. OLD_PT%Y.GE.1.D0) THEN
! 					K(2) = K(2) + 1
! 					IF (PATCH.LE.NUM_PATCH) THEN
! 						IF (DABS(PHY_PT%X).LE.EPS .AND. DABS(PHY_PT%Y).LE.EPS) THEN
! 							OLD_PT%Y = 0.D0
! 						ELSEIF (PHY_PT%X.GT.EPS .AND. DABS(PHY_PT%Y).LE.EPS) THEN
! 							IF (PATCH==1) THEN
! 								OLD_PT%Y = 0.D0
! 							ELSEIF (PATCH==4) THEN
! 								OLD_PT%Y = 1.D0
! 							ENDIF
! 						ELSE
! 							OLD_PT%Y = 0.0001D0*K(2)
! 						ENDIF
! 					ELSE
! 						OLD_PT%Y = 0.01D0*K(2)
! 					ENDIF
! 					ITER = 0
! 				ENDIF
! 				138 CONTINUE
			ENDIF
		ENDDO
		
		IF (ITER==MAX_ITERATION) THEN
			PRINT *, '[ERROR]  CANNOT FIND REFERENCE POINT !'
		ENDIF

		999 CONTINUE
		
! 		PRINT*, 'GET_REF_PT-HERE3'
		
	END FUNCTION GET_REF_PT


	!! BROYDEN METHOD (QUASI - NEWTON METHOD) FOR FINDING POINT EVALUATION OF INVERSE EXOTIC GEO. MAP. 
! 	TYPE(POINT2D) FUNCTION BROYDEN(REF_PT, PATCH)
! 	
! 		TYPE(POINT2D), INTENT(IN) :: REF_PT
! 		INTEGER, INTENT(IN) :: PATCH
! 		
! 		TYPE(POINT2D) :: OLD_PT, NEW_PT, V
! 		TYPE(MATRIX_22) :: JACOB
! 		
! 		JACOB = GET_JACOBIAN_MATRIX(REF_PT, PATCH)
! 		
! ! 		IF(PATCH==1) THEN
! ! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(1,:),GEO_CTL(1),1)
! ! 		ELSE
! ! 			CALL GET_DIFF_EXOTIC_GEO_MAP(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
! ! 		ENDIF
! 		
! 		V = GET_POINT_NURVE_SURFACE_2D(REF_PT,KVEC(PATCH,:),CTL(PATCH))
! 		
! 	END FUNCTION BROYDEN
	
	
	!! HOMOTOPY OR CONTINUATION ALGORITHM TO FIND GOOD INITIAL APPROXIMATION FOR NEWTON'S OR BROYDEN'S METHOD
	!! REFERENCE :: NUMERICAL ANALYSIS (BURDEN & FAIR)
	TYPE(POINT2D) FUNCTION GOOD_INITIAL(PHY_PT, PATCH)
		
		TYPE(POINT2D), INTENT(IN) :: PHY_PT
		INTEGER, INTENT(IN) :: PATCH
		
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
		TYPE(MATRIX_22) :: JACOB, INV_JACOB
		TYPE(POINT2D) :: K(4), OLD_PT, INI_B
		INTEGER :: I, J, II, JJ, MAX_IT
		REAL*8 :: STEP_H
		
		MAX_IT = 10
		STEP_H = 1.D0/(1.D0*MAX_IT)
		OLD_PT = POINT2D(0.5D0,0.5D0)
		
! 		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

		INI_B = GET_POINT_NURVE_SURFACE_2D(OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))
		INI_B%X = -STEP_H*(INI_B%X - PHY_PT%X)
		INI_B%Y = -STEP_H*(INI_B%Y - PHY_PT%Y)
		
		DO I = 1, MAX_IT
			JACOB = GET_JACOBIAN_MATRIX(OLD_PT, PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(1)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(1)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(1)%X, OLD_PT%Y + 0.5D0*K(1)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(2)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(2)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(2)%X, OLD_PT%Y + 0.5D0*K(2)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(3)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(3)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(3)%X, OLD_PT%Y + 0.5D0*K(3)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(4)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(4)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			OLD_PT%X = OLD_PT%X + (1.D0/6.D0)*(K(1)%X + 2.D0*K(2)%X + 2.D0*K(3)%X + K(4)%X)
			OLD_PT%Y = OLD_PT%Y + (1.D0/6.D0)*(K(1)%Y + 2.D0*K(2)%Y + 2.D0*K(3)%Y + K(4)%Y)
		ENDDO
		
		GOOD_INITIAL = OLD_PT
	END FUNCTION GOOD_INITIAL
	
	!!  GET JACOBIAN OF THE GEOMETRIC MAPPING
	TYPE(MATRIX_22) FUNCTION GET_JACOBIAN_MATRIX(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: PATCH

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

! 		IF (PRESENT(PATCH)) THEN
! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
! 		ELSE
! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(1,:),GEO_CTL(1),1)
! 		ENDIF

		GET_JACOBIAN_MATRIX%ENT(1,1) = DIFF_NURBS(1)%VAL(1,0)
		GET_JACOBIAN_MATRIX%ENT(1,2) = DIFF_NURBS(1)%VAL(0,1)
		GET_JACOBIAN_MATRIX%ENT(2,1) = DIFF_NURBS(2)%VAL(1,0)
		GET_JACOBIAN_MATRIX%ENT(2,2) = DIFF_NURBS(2)%VAL(0,1)

	END FUNCTION GET_JACOBIAN_MATRIX

	REAL*8 FUNCTION GET_DET_LN(REF_PT, GAMMA, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: GAMMA
		INTEGER, OPTIONAL, INTENT(IN) :: PATCH

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)

		IF (PRESENT(PATCH)) THEN
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
		ELSE
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(1,:),GEO_CTL(1),1)
		ENDIF

		IF (GAMMA.EQ.1 .OR. GAMMA.EQ.3 .OR. GAMMA.EQ.5) THEN
! 			PRINT*, DIFF_NURBS(1:2)%VAL(0,1)
			GET_DET_LN = DSQRT(DIFF_NURBS(1)%VAL(1,0)**2 + DIFF_NURBS(2)%VAL(1,0)**2)
		ELSE
			GET_DET_LN = DSQRT(DIFF_NURBS(1)%VAL(0,1)**2 + DIFF_NURBS(2)%VAL(0,1)**2)
		ENDIF

	END FUNCTION GET_DET_LN
	
	REAL*8 FUNCTION GET_DET_DR(REF_PT, PATCH, GAMMA_HAT)
	
		TYPE(POINT2D), INTENT(IN) :: REF_PT
		CHARACTER(LEN=1), INTENT(IN) :: GAMMA_HAT
		INTEGER, INTENT(IN) :: PATCH
	
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
	
		IF (GAMMA_HAT=='B' .OR. GAMMA_HAT=='T') THEN
			GET_DET_DR = DSQRT(DIFF_NURBS(1)%VAL(1,0)**2 + DIFF_NURBS(2)%VAL(1,0)**2)
		ELSEIF (GAMMA_HAT=='L' .OR. GAMMA_HAT=='R') THEN
			GET_DET_DR = DSQRT(DIFF_NURBS(1)%VAL(0,1)**2 + DIFF_NURBS(2)%VAL(0,1)**2)
		ELSE
			PRINT*, 'ERROR - GET_DET_DR : 1'
				STOP
		ENDIF

	END FUNCTION GET_DET_DR
	
	!!  GET SECOND-ORDER PARTIAL DERIVATIVES
	TYPE(SECOND_PARTIAL_DERIVATIVES) FUNCTION GET_PARTIAL(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, OPTIONAL, INTENT(IN) :: PATCH

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)

		IF (PRESENT(PATCH)) THEN
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),2)
		ELSE
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(1,:),GEO_CTL(1),2)
		ENDIF

		GET_PARTIAL%X(1) = DIFF_NURBS(1)%VAL(2,0)
		GET_PARTIAL%X(2) = DIFF_NURBS(1)%VAL(1,1)
		GET_PARTIAL%X(3) = DIFF_NURBS(1)%VAL(0,2)

		GET_PARTIAL%Y(1) = DIFF_NURBS(2)%VAL(2,0)
		GET_PARTIAL%Y(2) = DIFF_NURBS(2)%VAL(1,1)
		GET_PARTIAL%Y(3) = DIFF_NURBS(2)%VAL(0,2)

	END FUNCTION GET_PARTIAL

TYPE(POINT2D) FUNCTION AF_TRANS(REF_PT)
	
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	
	AF_TRANS = POINT2D(REF_PT%X + 1.D0, REF_PT%Y + (1.D0+DSQRT(2.D0)))
	
END FUNCTION AF_TRANS

END MODULE PATCH_MAPPING

