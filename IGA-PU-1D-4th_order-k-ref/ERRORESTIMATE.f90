MODULE ERRORESTIMATE

	USE GEOMETRY
	USE NURBS_BASIS
	USE LOADFUNCTION
	USE GSQUAD

    IMPLICIT NONE
    
CONTAINS

!----MAX. NORM ESTIMATE----
REAL*8 FUNCTION MAXNORM(COEFF_SOL)

	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
	
	TYPE(FUNCTION_1D) :: SING_UPBD, PHYPT, PARPT
	REAL*8 :: PHY_PT, PAR_PT, AP_SOL, EX_SOL, TMP_ERR, ERR, MAXU
	INTEGER :: I, II, J, JJ, PATCH


	TMP_ERR = 0.0D0
	ERR = 0.0D0
	MAXU = 0.0D0
	MAXNORM = 0.0D0
	
	OPEN(11, FILE = './data/ext')
	OPEN(21, FILE = './data/app')
	OPEN(31, FILE = './data/err')
	
	DO PATCH = 1, 2
      DO I = 1, 201
          PAR_PT = 0.0050D0*(I-1)
          IF (PATCH==1) THEN 
            PHYPT = MAP_F(PAR_PT)
          ELSEIF (PATCH==2) THEN 
            PHYPT = MAP_G(PAR_PT)
          ENDIF
          PHY_PT = PHYPT%VAL(0)
          AP_SOL = APSOL(PAR_PT, COEFF_SOL, PATCH)
          EX_SOL = EXSOL(PAR_PT, PATCH)
          TMP_ERR = DABS(EX_SOL - AP_SOL)
          WRITE(11,*) PHY_PT, EX_SOL
          WRITE(21,*) PHY_PT, AP_SOL
          WRITE(31,*) PHY_PT, TMP_ERR
          IF (TMP_ERR.GE.MAXNORM) THEN
              MAXNORM = TMP_ERR
          ENDIF
          IF (DABS(EX_SOL)>MAXU) THEN 
            MAXU = DABS(EX_SOL)
          ENDIF
      ENDDO
      WRITE(11,*) '';WRITE(21,*) '';WRITE(31,*) ''
      
    ENDDO
    CLOSE(11);CLOSE(21);CLOSE(31)
	
	MAXNORM = 100.0D0*MAXNORM/MAXU
	
END FUNCTION MAXNORM

SUBROUTINE ENRGY(ENRG, DMY_K, SOL)

	REAL*8, INTENT(IN) :: DMY_K(DOF,DOF), SOL(DOF)
	REAL*8, INTENT(OUT) :: ENRG(4)
	REAL*8 :: AP, TR
	INTEGER :: I, J

	AP = 0.50D0*DOT_PRODUCT(SOL, MATMUL(DMY_K, SOL))

	IF (PROBLEM==0) THEN
        TR = 0.50D0*((504.0D0 + 8505.0D0/PI**4 - 1890.0D0/PI**2 + 72.0D0*PI**2 + PI**4)/1260.0D0)
	ELSEIF (PROBLEM.EQ.1) THEN
		TR = 0.3040D0
!         TR = 0.269180D0
	ELSEIF (PROBLEM==2) THEN 
		TR = 0.50D0*((4.0D0/3.0D0) - 1.0D0)
    ELSEIF (PROBLEM==3) THEN 
        TR = 0.250D0*PI**2
	ENDIF

! 	CALL EXT_ENERGY(TR)

	ENRG(3) = DSQRT(DABS(AP - TR))*100.D0
	ENRG(4) = DSQRT(DABS(AP - TR) / TR)*100.D0

	ENRG(1) = TR; ENRG(2) = AP

!   OPEN(13, FILE=filename, STATUS='unknown', POSITION='append')
! 	WRITE(13,*) ''
! 	WRITE(13,*) 'EXACT ENERGY : ', ENRG(1)
! 	WRITE(13,*) 'APPR. ENERGY : ', ENRG(2)
! 	WRITE(13,*) 'ABS.  ENERGY NORM ERROR (%) : ', ENRG(3)
! 	WRITE(13,*) 'REL.  ENERGY NORM ERROR (%) : ', ENRG(4)
! 	CLOSE(13)
! 

	WRITE(*,*) ""
	WRITE(*,*) 'APPR. ENERGY : ', AP
	PRINT*, ""
	PRINT*, 'REL.  ENERGY NORM ERROR (%) : ', ENRG(4)
	PRINT*, ""


END SUBROUTINE ENRGY

! SUBROUTINE L2_NORM_ERROR(L2_NORM, COEFF_SOL)
! 	
! 	REAL*8, INTENT(OUT) :: L2_NORM(2)
! 	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
! 	INTEGER :: I, J, II, JJ, SUB_NUMLN(2), N, KK, K, PATCH
! 	REAL*8 :: SUB_LN_LENGTH(2), WEIGHT, DIFF_NN, DET_M
! 	REAL*8, ALLOCATABLE :: L2_GSX(:), L2_GSXW(:), L2_GSY(:), L2_GSYW(:)
! 	TYPE(VEC2D) :: SUB_LN
! 	TYPE(POINT2D) :: GSPT, DMY_GSPT, PHY_PT
! 	TYPE(MATRIX_22) :: JACOB
! 	TYPE(DISPLACEMENT) :: EXDISP, APDISP, INTF(2)
! 	TYPE(STRESS) :: APSTRESS
! 	
! 	N = 18
! 	ALLOCATE(L2_GSX(N), L2_GSY(N), L2_GSXW(N), L2_GSYW(N))
! 
! 	SUB_NUMLN = (/1,1/)
! 	INTF(:) = DISPLACEMENT(0.D0,0.D0,0.D0)
! 	
! 	DO JJ = 1, NUMIR(1)-1
! 		SUB_LN_LENGTH(1) = DABS(IR_GRID(1,JJ+1) - IR_GRID(1,JJ))/(1.D0*SUB_NUMLN(1))
! 		DO J=1, SUB_NUMLN(1)
! 			CALL GAULEG(IR_GRID(1,JJ)+(J-1)*SUB_LN_LENGTH(1), IR_GRID(1,JJ)+J*SUB_LN_LENGTH(1), L2_GSX, L2_GSXW, N)
! 			DO II = 1, NUMIR(2)-1
! 				SUB_LN_LENGTH(2) = DABS(IR_GRID(2,II+1) - IR_GRID(2,II))/(1.D0*SUB_NUMLN(2))
! 				DO I = 1, SUB_NUMLN(2)
! 					CALL GAULEG(IR_GRID(2,II)+(I-1)*SUB_LN_LENGTH(2), IR_GRID(2,II)+I*SUB_LN_LENGTH(2), L2_GSY, L2_GSYW, N)
! 					DO KK = 1, N
! 						DO K = 1, N
! 							GSPT = POINT2D(L2_GSX(KK),L2_GSY(K))
! 							DMY_GSPT = GSPT
! 							JACOB= GET_JACOBIAN_MATRIX(DMY_GSPT)
! 							DET_M = .DETERMINANT.JACOB
! ! 							PHY_PT = GET_PHY_PT(DMY_GSPT)
! 							EXDISP%PIX = EX_DISP(DMY_GSPT)
! 							CALL APPROXSOL(APDISP%PIX, DMY_GSPT, COEFF_SOL)
! 							INTF(1)%PIX = INTF(1)%PIX + (EXDISP%PIX - APDISP%PIX)**2*DET_M*L2_GSXW(KK)*L2_GSYW(K)
! ! 							INTF(1)%PIY = INTF(1)%PIY + (EXDISP%PIY - APDISP%PIY)**2*DET_M*GSXW(KK)*GSYW(K)
! 							INTF(2)%PIX = INTF(2)%PIX + EXDISP%PIX**2*DET_M*L2_GSXW(KK)*L2_GSYW(K)
! ! 							INTF(2)%PIY = INTF(2)%PIY + EXDISP%PIY**2*DET_M*GSXW(KK)*GSYW(K)
! 						ENDDO
! 					ENDDO
! 				ENDDO
! 			ENDDO
! 		ENDDO
! 	ENDDO
! 	
! 	L2_NORM(1) = DSQRT(INTF(1)%PIX/INTF(2)%PIX)*100.D0
! ! 	L2_NORM(2) = DSQRT(INTF(1)%PIY/INTF(2)%PIY)*100.D0
! 	
! ! 	OPEN(13, FILE=filename, STATUS='unknown', POSITION='append')
! ! 	WRITE(13,*) ''
! ! 	WRITE(13,*) 'RELATIVE ERROR IN L2 NORM (%) OF DISPLACEMENT ALONG X-DIRECTION : ', L2_NORM(1)
! ! 	WRITE(13,*) 'RELATIVE ERROR IN L2 NORM (%) OF DISPLACEMENT ALONG Y-DIRECTION : ', L2_NORM(2)
! ! 	CLOSE(1)
! 	
! END SUBROUTINE L2_NORM_ERROR

REAL*8 FUNCTION APSOL(REFPT, COEFF_SOL, PATCH)

	REAL*8, INTENT(IN) :: REFPT
	REAL*8, INTENT(IN) :: COEFF_SOL(DOF)
	INTEGER, INTENT(IN) :: PATCH
	
	TYPE(FUNCTION_1D) :: BS, PHYPT, PARPT
	INTEGER :: I, II, J, JJ
	
! 	TYPE(POINT2D) :: PHY_PT
! 	TYPE(MATRIX_22) :: JACOB
	
	APSOL = 0.0D0
    
    IF (PATCH==1) THEN
      PARPT = MAP_INVF(PATCHBDPT(1,2) - DELTA)
    ELSEIF (PATCH==2) THEN 
      PARPT = MAP_INVG(PATCHBDPT(2,1) + DELTA)
    ENDIF
    
    IF (PATCH==1 .AND. REFPT>PARPT%VAL(0)) THEN 
      II = 0
      DO I = 1, NUMBS(1)
          II = II + 1
          BS = GET_PHY_BASIS1D(NDX(2, II), REFPT, 1)
          APSOL = APSOL + COEFF_SOL(II)*BS%VAL(0)
      ENDDO
      PARPT = MAP_F(REFPT)
      PARPT = MAP_INVG(PARPT%VAL(0))
      II = NUMBS(1)
      DO I = 1, NUMBS(2)
          II = II + 1
          BS = GET_PHY_BASIS1D(NDX(2, II), PARPT%VAL(0), 2)
          APSOL = APSOL + COEFF_SOL(II)*BS%VAL(0)
      ENDDO
    ELSEIF (PATCH==2 .AND. REFPT<PARPT%VAL(0)) THEN 
      II = NUMBS(1)
      DO I = 1, NUMBS(2)
          II = II + 1
          BS = GET_PHY_BASIS1D(NDX(2, II), REFPT, 2)
          APSOL = APSOL + COEFF_SOL(II)*BS%VAL(0)
      ENDDO
      PARPT = MAP_G(REFPT)
      PARPT = MAP_INVF(PARPT%VAL(0))
      II = 0
      DO I = 1, NUMBS(1)
          II = II + 1
          BS = GET_PHY_BASIS1D(NDX(2, II), PARPT%VAL(0), 1)
          APSOL = APSOL + COEFF_SOL(II)*BS%VAL(0)
      ENDDO
    ELSE
      IF (PATCH==1) THEN
        II = 0
      ELSEIF (PATCH==2) THEN 
        II = NUMBS(1)
      ENDIF
		DO I = 1, NUMBS(PATCH)
			II = II + 1
			BS = GET_PHY_BASIS1D(NDX(2, II), REFPT, PATCH)
			APSOL = APSOL + COEFF_SOL(II)*BS%VAL(0)
		ENDDO
    ENDIF
    
END FUNCTION APSOL

END MODULE ERRORESTIMATE
