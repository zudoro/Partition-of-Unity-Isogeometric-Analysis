	MODULE INTEGRATION

! 	USE GSQUAD
	USE LUDECOMPOSITION
	USE NURBS_PU
	USE INTERPOLATION
	USE LOADFUNCTION

CONTAINS



!------------------INTEGRAL CODE FOR THE STIFFNESS MATRIX ELEMENT--------------
SUBROUTINE GEN_KF(STIF_K, LOAD_F)

	REAL*8, INTENT(OUT) :: STIF_K(DOF, DOF), LOAD_F(DOF)
	TYPE(POINT2D) :: COLPT
	TYPE(INT2D) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	TYPE(MATRIX_22) :: JACOB
	TYPE(FVALUE) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	INTEGER :: I, J, II, JJ, KK, N, GLB_NDX
	
	STIF_K(:,:) = 0.D0; LOAD_F(:) = 0.D0
	
	K = 0
	DO JJ = 1, NUMBS(2)
		DO II = 1, NUMBS(1)
			K = K + 1
			COLPT = POINT2D(GREV_PTX(II), GREV_PTY(JJ))
			JACOB = GET_JACOBIAN_MATRIX(COLPT)
			CALL GET_ALL_PHY_BASIS_IN_INT(SF(:), INDX(:), COLPT, JACOB)
! 			CALL GET_ALL_PHY_NURBS_SURFACE_2D(SF(:), INDX(:), COLPT, JACOB)
			
			!--------------------EVALUATE INTEGRAND AT EACH GAUSS POINT IN SUBMATRIX-----------
			DO J = 1, (BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1)
				DO KK = 1, DOF
					IF (NDX(1,KK).EQ.INDX(J)%A .AND. NDX(2,KK).EQ.INDX(J)%B) THEN
						GLB_NDX = KK
						GOTO 222
					ELSE
						GLB_NDX = 0
					ENDIF
				ENDDO
				222 CONTINUE
				IF (GLB_NDX.NE.0) THEN
					STIF_K(K,GLB_NDX) = -(SF(J)%D20 + SF(J)%D02)
				ENDIF
			ENDDO
			LOAD_F(K) = LDFT2D(COLPT)
! 			IF (K==10) THEN
! 				PRINT*, COLPT
! 				PRINT*, LOAD_F(K)
! 			ENDIF
		ENDDO
	ENDDO
	
	WRITE(*,*)
	WRITE(*,*) '<<< ASSEMBLE STIFFNESS MATRIX AND LOAD VECTOR : DONE >>>'
	WRITE(*,*)
	
END SUBROUTINE GEN_KF

SUBROUTINE GEN_BD_LN()

	REAL*8 :: SUB_K(BDNDX(1)%LC_NUM, BDNDX(1)%LC_NUM)
	REAL*8 :: SUB_F(BDNDX(1)%LC_NUM)
	REAL*8 :: DD
	INTEGER :: I, J, II, JJ, KK, GLB_NDX, LU_INDX(BDNDX(1)%LC_NUM)
	
	TYPE(FVALUE) :: SF((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	TYPE(INT2D) :: INDX((BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1))
	TYPE(POINT2D) :: COLPT
	TYPE(MATRIX_22) :: JACOB
	CHARACTER(LEN=1) :: GAMMA_HAT
	
	IF (BDNDX(1)%LC_NUM.NE.UBOUND(BD_COL_PT,1)) THEN
		PRINT*, 'NUM. OF BASIS ON BD. IS NOT EQUAL TO NUM. OF COL. PT. ON BD.'
		PRINT*, 'NUM. OF BASIS ON BD. : ', BDNDX(1)%LC_NUM
		PRINT*, 'NUM. OF. COL. PT. ON BD. : ', UBOUND(BD_COL_PT,1)
		STOP
	ENDIF
	
	SUB_K(:,:)=0.D0; SUB_F(:) = 0.D0

	DO II = 1, BDNDX(1)%LC_NUM
		JACOB = GET_JACOBIAN_MATRIX(BD_COL_PT(II))
		CALL GET_ALL_PHY_BASIS_IN_INT(SF(:), INDX, BD_COL_PT(II), JACOB)
! 		CALL GET_ALL_PHY_NURBS_SURFACE_2D(SF(:), INDX(:), BD_COL_PT(II), JACOB)
		DO J = 1, (BASIS_KVEC(1)%POLY_ORDER+1)*(BASIS_KVEC(2)%POLY_ORDER+1)
			DO KK = 1, BDNDX(1)%LC_NUM
				IF (BDNDX(KK)%LC_NDX(1).EQ.INDX(J)%A .AND. BDNDX(KK)%LC_NDX(2).EQ.INDX(J)%B) THEN
					GLB_NDX = KK
					GOTO 222
				ELSE
					GLB_NDX = 0
				ENDIF
			ENDDO
			222 CONTINUE
			IF (GLB_NDX.NE.0) THEN
				SUB_K(II, GLB_NDX) = SF(J)%D00
			ENDIF
		ENDDO
		SUB_F(II) = EX_DISP(BD_COL_PT(II))
	ENDDO
	
! 	OPEN(124, FILE = './data/sub_k')
! 	OPEN(125, FILE = './data/sub_f')
! 	DO I=1, BDNDX(1)%LC_NUM
! 		WRITE(124, *) (SUB_K(I,J), J=1,BDNDX(1)%LC_NUM)
! 		WRITE(125, *) SUB_F(I)
! 	ENDDO
! 	CLOSE(124)
! 	CLOSE(125)
	
	CALL LUDCMP(SUB_K, BDNDX(1)%LC_NUM, BDNDX(1)%LC_NUM, LU_INDX, DD)
	CALL LUBKSB(SUB_K, BDNDX(1)%LC_NUM, BDNDX(1)%LC_NUM, LU_INDX, SUB_F)
	
! 	OPEN(126, FILE = './data/sub_s')
! 	DO I=1, BDNDX(1)%LC_NUM
! 		WRITE(126, *) SUB_F(I)
! 	ENDDO
! 	CLOSE(126)
	
	LST_SOL(:) = SUB_F(:)
	
END SUBROUTINE GEN_BD_LN

END MODULE INTEGRATION
