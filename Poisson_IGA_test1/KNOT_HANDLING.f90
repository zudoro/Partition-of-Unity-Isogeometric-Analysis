MODULE KNOT_HANDLING

	USE NEWTYPE

	IMPLICIT INTEGER (I-N)
	IMPLICIT REAL(8) (A-H,O-Z)

	INTERFACE OPERATOR (+)
		MODULE PROCEDURE TRANSLATE_KNOT_VECTOR
	END INTERFACE

	INTERFACE OPERATOR (*)
		MODULE PROCEDURE RESCALE_KNOT_VECTOR
	END INTERFACE

	INTERFACE OPERATOR (.NORMAL.)
		MODULE PROCEDURE NORMALIZE_KNOT_VECTOR
	END INTERFACE

CONTAINS

	!!  GENERATE BASE OPEN KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION GET_BASE_OPEN_KNOT_VECTOR(POLY_ORDER,NUMBER_OF_BASIS)

		INTEGER, INTENT(IN) :: POLY_ORDER, NUMBER_OF_BASIS

		INTEGER :: NADD

		IF (NUMBER_OF_BASIS>0 .AND. NUMBER_OF_BASIS<(POLY_ORDER+1)) THEN
			PRINT *, '[ERROR]  GIVEN NUMBER OF BASIS IS TOO SMALL !'
			NADD = 0
		ENDIF

		IF (NUMBER_OF_BASIS<=0) THEN
			NADD = 0
		ELSE
			NADD = NUMBER_OF_BASIS - (POLY_ORDER+1)
		ENDIF

		GET_BASE_OPEN_KNOT_VECTOR%POLY_ORDER = POLY_ORDER
		GET_BASE_OPEN_KNOT_VECTOR%LENGTH = -1
		DO I = 0, POLY_ORDER
			GET_BASE_OPEN_KNOT_VECTOR%KNOTS(GET_BASE_OPEN_KNOT_VECTOR%LENGTH+1) = 0.0D0
			GET_BASE_OPEN_KNOT_VECTOR%LENGTH = GET_BASE_OPEN_KNOT_VECTOR%LENGTH + 1
		ENDDO
		DO I = 1, NADD
			GET_BASE_OPEN_KNOT_VECTOR%KNOTS(GET_BASE_OPEN_KNOT_VECTOR%LENGTH+1) = (I*1.0D0)/(NADD+1)
			GET_BASE_OPEN_KNOT_VECTOR%LENGTH = GET_BASE_OPEN_KNOT_VECTOR%LENGTH + 1
		ENDDO
		DO I = 0, POLY_ORDER
			GET_BASE_OPEN_KNOT_VECTOR%KNOTS(GET_BASE_OPEN_KNOT_VECTOR%LENGTH+1) = 1.0D0
			GET_BASE_OPEN_KNOT_VECTOR%LENGTH = GET_BASE_OPEN_KNOT_VECTOR%LENGTH + 1
		ENDDO

	END FUNCTION GET_BASE_OPEN_KNOT_VECTOR

	!!  GENERATE BASE OPEN KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION GET_OPEN_KNOT_VECTOR(POLY_ORDER)

		INTEGER, INTENT(IN) :: POLY_ORDER

		GET_OPEN_KNOT_VECTOR%POLY_ORDER = POLY_ORDER
		GET_OPEN_KNOT_VECTOR%LENGTH = -1
		DO I = 0, POLY_ORDER
			GET_OPEN_KNOT_VECTOR%KNOTS(GET_OPEN_KNOT_VECTOR%LENGTH+1) = 0.0D0
			GET_OPEN_KNOT_VECTOR%LENGTH = GET_OPEN_KNOT_VECTOR%LENGTH + 1
		ENDDO
		DO I = 0, POLY_ORDER
			GET_OPEN_KNOT_VECTOR%KNOTS(GET_OPEN_KNOT_VECTOR%LENGTH+1) = 1.0D0
			GET_OPEN_KNOT_VECTOR%LENGTH = GET_OPEN_KNOT_VECTOR%LENGTH + 1
		ENDDO

	END FUNCTION GET_OPEN_KNOT_VECTOR


	!!  TRANSLATE KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION TRANSLATE_KNOT_VECTOR(PT,KVEC)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC

		DO K = 0, KVEC%LENGTH
			TRANSLATE_KNOT_VECTOR%KNOTS(K) = KVEC%KNOTS(K) + PT
		ENDDO
		TRANSLATE_KNOT_VECTOR%LENGTH = KVEC%LENGTH
		TRANSLATE_KNOT_VECTOR%POLY_ORDER = KVEC%POLY_ORDER

	END FUNCTION TRANSLATE_KNOT_VECTOR


	!!  RESCALE KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION RESCALE_KNOT_VECTOR(SCALAR,KVEC)

		REAL(8), INTENT(IN) :: SCALAR
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC

		DO K = 0, KVEC%LENGTH
			RESCALE_KNOT_VECTOR%KNOTS(K) = SCALAR * KVEC%KNOTS(K)
		ENDDO
		RESCALE_KNOT_VECTOR%LENGTH = KVEC%LENGTH
		RESCALE_KNOT_VECTOR%POLY_ORDER = KVEC%POLY_ORDER

	END FUNCTION RESCALE_KNOT_VECTOR


	!!  NORMALIZE KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION NORMALIZE_KNOT_VECTOR(KVEC)

		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC

		REAL(8) :: FACTOR

		FACTOR = KVEC%KNOTS(KVEC%LENGTH) - KVEC%KNOTS(0)
		DO K = 0, KVEC%LENGTH
			NORMALIZE_KNOT_VECTOR%KNOTS(K) = (KVEC%KNOTS(K)-KVEC%KNOTS(0)) / FACTOR
		ENDDO
		NORMALIZE_KNOT_VECTOR%LENGTH = KVEC%LENGTH
		NORMALIZE_KNOT_VECTOR%POLY_ORDER = KVEC%POLY_ORDER

	END FUNCTION NORMALIZE_KNOT_VECTOR


	!!  INSERT KNOT VALUES. DOES NOT CHANGE THE POLYNOMIAL ORDER
	TYPE(KNOT_VECTOR) FUNCTION KNOT_INSERTION(KVEC)

		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC

		REAL(8) :: KNOTS(MAX_LENGTH), NEW_KNOT
		INTEGER :: POLY_ORDER, MULTIPLICITIES(MAX_LENGTH), NUM_KNOTS, MENU
		LOGICAL :: INSERTED

		KNOT_INSERTION = KVEC
		CALL KNOT_TO_ARRAY(KVEC,POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)
		WRITE(*,*)
		WRITE(*,FMT='(A,I2,A)') ' ** THERE ARE ', NUM_KNOTS, ' DISTINCT KNOT VALUES IN THE GIVEN KNOT VECTOR.'
		WRITE(*,*)
		DO K = 1, NUM_KNOTS
			WRITE(*,101) K, KNOTS(K), MULTIPLICITIES(K)
		ENDDO
		WRITE(*,*)
		100 WRITE(*,FMT='(A)',ADVANCE='NO') ' ** SELECT ONE  :  [1] INSERT A KNOT, [0] QUIT  >> '
		READ(*,*,ERR=100) MENU
		IF (MENU/=1 .AND. MENU/=0) GOTO 100
		WRITE(*,*)
		DO WHILE (MENU/=0)
			WRITE(*,FMT='(A)',ADVANCE='NO') '    ENTER A KNOT FROM (0,1) >> '
			READ(*,*) NEW_KNOT
			IF (NEW_KNOT>0.0D0 .AND. NEW_KNOT<1.0D0) THEN
				INSERTED = .FALSE.
				DO K = 2, NUM_KNOTS
					IF ((.NOT.INSERTED) .AND. ABS(NEW_KNOT-KNOTS(K))<TOLERANCE) THEN
						IF (MULTIPLICITIES(K)/=KVEC%POLY_ORDER) THEN
							MULTIPLICITIES(K) = MULTIPLICITIES(K) + 1
							INSERTED = .TRUE.
						ENDIF
					ELSE IF ((.NOT.INSERTED) .AND. (NEW_KNOT>KNOTS(K-1)) .AND. (NEW_KNOT<KNOTS(K)))THEN
						DO J = NUM_KNOTS, K, -1
							KNOTS(J+1) = KNOTS(J)
							MULTIPLICITIES(J+1) = MULTIPLICITIES(J)
						ENDDO
						KNOTS(K) = NEW_KNOT
						MULTIPLICITIES(K) = 1
						NUM_KNOTS = NUM_KNOTS + 1
					ENDIF
				ENDDO
			ENDIF
			WRITE(*,*)
			WRITE(*,FMT='(A,I2,A)') ' ** THERE ARE ', NUM_KNOTS, ' DISTINCT KNOT VALUES IN THE GIVEN KNOT VECTOR.'
			WRITE(*,*)
			DO K = 1, NUM_KNOTS
				WRITE(*,101) K, KNOTS(K), MULTIPLICITIES(K)
			ENDDO
			WRITE(*,*)
			200 WRITE(*,FMT='(A)',ADVANCE='NO') ' ** SELECT ONE  :  [1] INSERT A KNOT, [9] SAVE AND QUIT, [0] QUIT  >> '
			READ(*,*,ERR=200) MENU
			IF (MENU/=1 .AND. MENU/=9 .AND. MENU/=0) GOTO 200
			WRITE(*,*)
			IF (MENU==9) THEN
				KNOT_INSERTION = ARRAY_TO_KNOT(POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)
				MENU = 0
			ENDIF
		ENDDO

		101 FORMAT(5X,'[',I2.2,']',2XF8.5,5X,'X ',I2)

	END FUNCTION KNOT_INSERTION


	!!  INSERT KNOT VALUES. DOES NOT CHANGE THE POLYNOMIAL ORDER
	TYPE(KNOT_VECTOR) FUNCTION UNIFORM_KNOT_INSERTION(KVEC,NUM_INSERTION)

		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		INTEGER, INTENT(IN) :: NUM_INSERTION

		REAL(8) :: KNOTS(MAX_LENGTH), NEW_KNOTS(MAX_LENGTH)
		INTEGER :: POLY_ORDER, MULTIPLICITIES(MAX_LENGTH), NEW_MULTIPLICITIES(MAX_LENGTH), NUM_KNOTS

		CALL KNOT_TO_ARRAY(KVEC,POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)
		NEW_KNOTS(1) = KNOTS(1)
		NEW_MULTIPLICITIES(1) = MULTIPLICITIES(1)
		DO K = 2, NUM_KNOTS
			DO J = 1, NUM_INSERTION
				INDX = (K-1)*(NUM_INSERTION+1)-NUM_INSERTION+J
				NEW_KNOTS(INDX) = (1.0D0*J)*(KNOTS(K)-KNOTS(K-1))/(NUM_INSERTION+1) + KNOTS(K-1)
				NEW_MULTIPLICITIES(INDX) = 1
			ENDDO
			NEW_KNOTS(K*(NUM_INSERTION+1)-NUM_INSERTION) = KNOTS(K)
			NEW_MULTIPLICITIES(K*(NUM_INSERTION+1)-NUM_INSERTION) = MULTIPLICITIES(K)
		ENDDO
		UNIFORM_KNOT_INSERTION = ARRAY_TO_KNOT(POLY_ORDER,NUM_KNOTS*(NUM_INSERTION+1)-NUM_INSERTION,NEW_KNOTS,NEW_MULTIPLICITIES)

	END FUNCTION UNIFORM_KNOT_INSERTION


	!!  INSERT KNOT VALUES. DOES NOT CHANGE THE POLYNOMIAL ORDER
	TYPE(KNOT_VECTOR) FUNCTION DEGREE_ELEVATION(KVEC,REGULARITY_OPTION)

		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		LOGICAL, OPTIONAL, INTENT(IN) :: REGULARITY_OPTION

		REAL(8) :: KNOTS(MAX_LENGTH)
		INTEGER :: POLY_ORDER, MULTIPLICITIES(MAX_LENGTH), NUM_KNOTS
		LOGICAL :: INCREASE_REGULARITY

		CALL KNOT_TO_ARRAY(KVEC,POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)
		IF (PRESENT(REGULARITY_OPTION)) THEN
			IF (REGULARITY_OPTION) THEN
				INCREASE_REGULARITY = .TRUE.
			ELSE
				INCREASE_REGULARITY = .FALSE.
			ENDIF
		ELSE
				INCREASE_REGULARITY = .FALSE.
		ENDIF

		IF (INCREASE_REGULARITY) THEN
			MULTIPLICITIES(1) = MULTIPLICITIES(1) + 1
			MULTIPLICITIES(NUM_KNOTS) = MULTIPLICITIES(NUM_KNOTS) + 1
			DEGREE_ELEVATION = ARRAY_TO_KNOT(POLY_ORDER+1,NUM_KNOTS,KNOTS,MULTIPLICITIES)
		ELSE
			DO K = 1, NUM_KNOTS
				MULTIPLICITIES(K) = MULTIPLICITIES(K) + 1
			ENDDO
			DEGREE_ELEVATION = ARRAY_TO_KNOT(POLY_ORDER+1,NUM_KNOTS,KNOTS,MULTIPLICITIES)
		ENDIF

	END FUNCTION DEGREE_ELEVATION


	!!  CONVERT A KNOT VECTOR TO LISTS OF KNOTS AND MULTIPLICITIES
	SUBROUTINE KNOT_TO_ARRAY(KVEC,POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)

		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		INTEGER, INTENT(OUT) :: POLY_ORDER, NUM_KNOTS, MULTIPLICITIES(MAX_LENGTH)
		REAL(8), INTENT(OUT) :: KNOTS(MAX_LENGTH)

		POLY_ORDER = KVEC%POLY_ORDER
		NUM_KNOTS = 1
		KNOTS(NUM_KNOTS) = KVEC%KNOTS(0)
		MULTIPLICITIES(NUM_KNOTS) = 1
		DO K = 1, KVEC%LENGTH
			IF (ABS(KNOTS(NUM_KNOTS)-KVEC%KNOTS(K))<TOLERANCE) THEN
				MULTIPLICITIES(NUM_KNOTS) = MULTIPLICITIES(NUM_KNOTS) + 1
			ELSE
				NUM_KNOTS = NUM_KNOTS + 1
				KNOTS(NUM_KNOTS) = KVEC%KNOTS(K)
				MULTIPLICITIES(NUM_KNOTS) = 1
			ENDIF
		ENDDO

	END SUBROUTINE KNOT_TO_ARRAY


	!!  CONVERT LISTS OF KNOTS AND MULTIPLICITIES TO A KNOT VECTOR
	TYPE(KNOT_VECTOR) FUNCTION ARRAY_TO_KNOT(POLY_ORDER,NUM_KNOTS,KNOTS,MULTIPLICITIES)

		INTEGER, INTENT(IN) :: POLY_ORDER, NUM_KNOTS, MULTIPLICITIES(MAX_LENGTH)
		REAL(8), INTENT(IN) :: KNOTS(MAX_LENGTH)

		ARRAY_TO_KNOT%POLY_ORDER = POLY_ORDER
		ARRAY_TO_KNOT%LENGTH = -1
		DO K = 1, NUM_KNOTS
			DO J = 1, MULTIPLICITIES(K)
				ARRAY_TO_KNOT%LENGTH = ARRAY_TO_KNOT%LENGTH + 1
				ARRAY_TO_KNOT%KNOTS(ARRAY_TO_KNOT%LENGTH) = KNOTS(K)
			ENDDO
		ENDDO

	END FUNCTION ARRAY_TO_KNOT


END MODULE KNOT_HANDLING