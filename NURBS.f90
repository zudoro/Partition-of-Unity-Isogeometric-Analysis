MODULE NURBS

	USE GLBVAR
	USE KNOT_HANDLING

	IMPLICIT NONE

CONTAINS

	!!  FIND ALL NON-VANISHING B-SPLINE FUNCTIONS
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR
	!!  OUTPUT : STRUCTURE "BSPLINES"
	TYPE(BSPLINES) FUNCTION GET_ALL_BSPLINES(PT,KVEC)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC

		REAL(8) :: N(0:KVEC%POLY_ORDER), LEFT(KVEC%POLY_ORDER), RIGHT(KVEC%POLY_ORDER), SAVED, TEMP
		INTEGER :: I, J, K

		I = FIND_KNOT_SPAN(PT,KVEC)

		IF (I>=0) THEN
			N(0) = 1.0D0
			DO J = 1, KVEC%POLY_ORDER
				LEFT(J) = PT - KVEC%KNOTS(I+1-J)
				RIGHT(J) = KVEC%KNOTS(I+J) - PT
				SAVED = 0.0D0
				DO K = 0, J-1
					TEMP = N(K) / (RIGHT(K+1)+LEFT(J-K))
					N(K) = SAVED + RIGHT(K+1)*TEMP
					SAVED = LEFT(J-K)*TEMP
				ENDDO
				N(J) = SAVED
			ENDDO
			DO J = 0, KVEC%POLY_ORDER
				GET_ALL_BSPLINES%N(J) = N(J)
			ENDDO
			GET_ALL_BSPLINES%POLY_ORDER = KVEC%POLY_ORDER
			GET_ALL_BSPLINES%INIT = I - KVEC%POLY_ORDER
		ENDIF

	END FUNCTION GET_ALL_BSPLINES

 
	!!  FIND ALL NON-VANISHING B-SPLINE FUNCTIONS AND THEIR DERIVATIVES
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : STRUCTURE "DIFF_BSPLINES"
	TYPE(DIFF_BSPLINES) FUNCTION GET_ALL_DIFF_BSPLINES(PT,KVEC,DIFF_ORDER)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		INTEGER, INTENT(IN) :: DIFF_ORDER

		REAL(8) :: DERS(0:DIFF_ORDER,0:KVEC%POLY_ORDER), NDU(0:KVEC%POLY_ORDER,0:KVEC%POLY_ORDER)
		REAL(8) :: LEFT(KVEC%POLY_ORDER), RIGHT(KVEC%POLY_ORDER), A(0:1,0:KVEC%POLY_ORDER), SAVED, TEMP
		INTEGER :: ROW1, ROW2, DIFF_LK, DIFF_PK, LOW, HIGH
		INTEGER :: I, J, K, L

		I = FIND_KNOT_SPAN(PT,KVEC)

		IF (I>=0) THEN
			NDU(0,0) = 1.0D0
			DO J = 1, KVEC%POLY_ORDER
				LEFT(J) = PT - KVEC%KNOTS(I+1-J)
				RIGHT(J) = KVEC%KNOTS(I+J) - PT
				SAVED = 0.0D0
				DO K = 0, J-1
					NDU(J,K) = RIGHT(K+1) + LEFT(J-K)
					TEMP = NDU(K,J-1) / NDU(J,K)
					NDU(K,J) = SAVED + RIGHT(K+1)*TEMP
					SAVED = LEFT(J-K)*TEMP
				ENDDO
				NDU(J,J) = SAVED
			ENDDO
			DO J = 0, KVEC%POLY_ORDER
				DERS(0,J) = NDU(J,KVEC%POLY_ORDER)
			ENDDO
			DO L = 0, KVEC%POLY_ORDER
				ROW1 = 0
				ROW2 = 1
				A(0,0) = 1.0D0
				DO K = 1, DIFF_ORDER
					TEMP = 0.0D0
					DIFF_LK = L - K
					DIFF_PK = KVEC%POLY_ORDER - K
					IF (DIFF_LK>=0) THEN
						A(ROW2,0) = A(ROW1,0) / NDU(DIFF_PK+1,DIFF_LK)
						TEMP = A(ROW2,0) * NDU(DIFF_LK,DIFF_PK)
					ENDIF
					IF (DIFF_LK>=-1) THEN
						LOW = 1
					ELSE
						LOW = -DIFF_LK
					ENDIF
					IF (L-1<=DIFF_PK) THEN
						HIGH = K - 1
					ELSE
						HIGH = KVEC%POLY_ORDER - L
					ENDIF
					DO J = LOW, HIGH
						A(ROW2,J) = (A(ROW1,J)-A(ROW1,J-1)) / NDU(DIFF_PK+1,DIFF_LK+J)
						TEMP = TEMP + A(ROW2,J) * NDU(DIFF_LK+J,DIFF_PK)
					ENDDO
					IF (L<=DIFF_PK) THEN
						A(ROW2,K) = -A(ROW1,K-1) / NDU(DIFF_PK+1,L)
						TEMP = TEMP + A(ROW2,K) * NDU(L,DIFF_PK)
					ENDIF
					DERS(K,L) = TEMP
					J = ROW1
					ROW1 = ROW2
					ROW2 = J
				ENDDO
			ENDDO
			L = KVEC%POLY_ORDER
			DO K = 1, DIFF_ORDER
				DO J = 0, KVEC%POLY_ORDER
					DERS(K,J) = DERS(K,J) * L
				ENDDO
				L = L * (KVEC%POLY_ORDER-K)
			ENDDO
			DO J = 0, KVEC%POLY_ORDER
			DO K = 0, DIFF_ORDER
				GET_ALL_DIFF_BSPLINES%N(J,K) = DERS(K,J)
			ENDDO
			ENDDO
			GET_ALL_DIFF_BSPLINES%POLY_ORDER = KVEC%POLY_ORDER
			GET_ALL_DIFF_BSPLINES%INIT = I - KVEC%POLY_ORDER
			GET_ALL_DIFF_BSPLINES%DIFF_ORDER = DIFF_ORDER
		ENDIF

	END FUNCTION GET_ALL_DIFF_BSPLINES


	!!  FIND THE INDICATED B-SPLINE FUNCTION
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, INDX - INDEX
	!!  OUTPUT : "REAL(8)" B-SPLINE FUNCTION VALUE
	REAL(8) FUNCTION GET_BSPLINE(PT,KVEC,INDX)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		INTEGER, INTENT(IN) :: INDX

		REAL(8) :: N(0:KVEC%POLY_ORDER), SAVED, TEMP
		INTEGER :: I, J, K, L

		IF (INDX==0 .AND. ABS(PT-KVEC%KNOTS(0))<TOLERANCE) THEN
			GET_BSPLINE = 1.0D0
		ELSE IF (INDX==(KVEC%LENGTH-KVEC%POLY_ORDER-1) .AND. ABS(PT-KVEC%KNOTS(KVEC%LENGTH))<TOLERANCE) THEN
			GET_BSPLINE = 1.0D0
		ELSE IF ((PT<KVEC%KNOTS(INDX)-TOLERANCE) .OR. (PT>=KVEC%KNOTS(INDX+KVEC%POLY_ORDER+1)+TOLERANCE)) THEN
			GET_BSPLINE = 0.0D0
		ELSE
			DO J = 0, KVEC%POLY_ORDER
				IF (PT>=KVEC%KNOTS(INDX+J) .AND. PT<KVEC%KNOTS(INDX+J+1)) THEN
					N(J) = 1.0D0
				ELSE
					N(J) = 0.0D0
				ENDIF
			ENDDO
			DO K = 1, KVEC%POLY_ORDER
				IF (ABS(N(0))<TOLERANCE) THEN
					SAVED = 0.0D0
				ELSE
					SAVED = ((PT-KVEC%KNOTS(INDX))*N(0)) / (KVEC%KNOTS(INDX+K)-KVEC%KNOTS(INDX))
				ENDIF
				DO J = 0, KVEC%POLY_ORDER-K
					IF (ABS(N(J+1))<TOLERANCE) THEN
						N(J) = SAVED
						SAVED = 0.0D0
					ELSE
						TEMP = N(J+1) / (KVEC%KNOTS(INDX+J+K+1)-KVEC%KNOTS(INDX+J+1))
						N(J) = SAVED + (KVEC%KNOTS(INDX+J+K+1)-PT)*TEMP
						SAVED = (PT-KVEC%KNOTS(INDX+J+1))*TEMP
					ENDIF
				ENDDO
			ENDDO
			GET_BSPLINE = N(0)
		ENDIF

	END FUNCTION GET_BSPLINE


	!!  FIND THE INDICATED B-SPLINE FUNCTION AND ITS DERIVATIVES
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, INDX - INDEX, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : STRUCTURE "FUNCTION_1D" B-SPLINE FUNCTION VALUE AND ITS DERIVATIVES
	TYPE(FUNCTION_1D) FUNCTION GET_DIFF_BSPLINE(PT,KVEC,INDX,DIFF_ORDER)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		INTEGER, INTENT(IN) :: INDX, DIFF_ORDER

		REAL(8) :: N(0:KVEC%POLY_ORDER,0:KVEC%POLY_ORDER), ND(0:DIFF_ORDER), SAVED, TEMP
		INTEGER :: I, J, K, L, II, JJ, KK, LL

		IF (INDX==(KVEC%LENGTH-KVEC%POLY_ORDER-1) .AND. DABS(PT-KVEC%KNOTS(KVEC%LENGTH)).LE.TOLERANCE) THEN
			GET_DIFF_BSPLINE%VAL(0) = 1.0D0
			DO K = 1, DIFF_ORDER
				GET_DIFF_BSPLINE%VAL(K) = 0.0D0
			ENDDO
		ELSE IF ((PT<KVEC%KNOTS(INDX)-TOLERANCE) .OR. (PT>=KVEC%KNOTS(INDX+KVEC%POLY_ORDER+1)+TOLERANCE)) THEN
			DO K = 0, DIFF_ORDER
				GET_DIFF_BSPLINE%VAL(K) = 0.0D0
			ENDDO
		ELSE
			DO J = 0, KVEC%POLY_ORDER
				IF (PT>=KVEC%KNOTS(INDX+J) .AND. PT<KVEC%KNOTS(INDX+J+1)) THEN
					N(J,0) = 1.0D0
				ELSE
					N(J,0) = 0.0D0
				ENDIF
			ENDDO
			DO K = 1, KVEC%POLY_ORDER
				IF (ABS(N(0,K-1))<TOLERANCE) THEN
					SAVED = 0.0D0
				ELSE
					SAVED = ((PT-KVEC%KNOTS(INDX))*N(0,K-1)) / (KVEC%KNOTS(INDX+K)-KVEC%KNOTS(INDX))
				ENDIF
				DO J = 0, KVEC%POLY_ORDER-K
					IF (ABS(N(J+1,K-1))<TOLERANCE) THEN
						N(J,K) = SAVED
						SAVED = 0.0D0
					ELSE
						TEMP = N(J+1,K-1) / (KVEC%KNOTS(INDX+J+K+1)-KVEC%KNOTS(INDX+J+1))
						N(J,K) = SAVED + (KVEC%KNOTS(INDX+J+K+1)-PT)*TEMP
						SAVED = (PT-KVEC%KNOTS(INDX+J+1))*TEMP
					ENDIF
				ENDDO
			ENDDO
			GET_DIFF_BSPLINE%VAL(0) = N(0,KVEC%POLY_ORDER)
			DO K = 1, DIFF_ORDER
				DO J = 0, K
					ND(J) = N(J,KVEC%POLY_ORDER-K)
				ENDDO
				DO JJ = 1, K
					IF (ABS(ND(0))<TOLERANCE) THEN
						SAVED = 0.0D0
					ELSE
						SAVED = ND(0) / (KVEC%KNOTS(INDX+KVEC%POLY_ORDER-K+JJ)-KVEC%KNOTS(INDX))
					ENDIF
					DO J = 0, K-JJ
						IF (ABS(ND(J+1))<TOLERANCE) THEN
							ND(J) = (KVEC%POLY_ORDER-K+JJ) * SAVED
							SAVED = 0.0D0
						ELSE
							TEMP = ND(J+1) / (KVEC%KNOTS(INDX+KVEC%POLY_ORDER-K+JJ+J+1)-KVEC%KNOTS(INDX+J+1))
							ND(J) = (KVEC%POLY_ORDER-K+JJ) * (SAVED-TEMP)
							SAVED = TEMP
						ENDIF
					ENDDO
				ENDDO
				GET_DIFF_BSPLINE%VAL(K) = ND(0)
			ENDDO
		ENDIF

	END FUNCTION GET_DIFF_BSPLINE


	!!  FIND A POINT ON NURBS CURVE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR
	!!  OUTPUT : A POINT ON THE NURBS CURVE
	TYPE(POINT2D) FUNCTION GET_POINT_NURVE_CURVE_2D(PT,KVEC,CTL)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL

		TYPE(BSPLINES) :: BSFUN
		TYPE(POINT2D) :: WCPTSUM
		REAL(8) :: WSUM
		INTEGER :: INDX
		INTEGER :: I, J, K

		IF (CTL%D==1) THEN
			BSFUN =  GET_ALL_BSPLINES(PT,KVEC)
			WCPTSUM = POINT2D(0.0D0,0.0D0)
			WSUM = 0.0D0
			DO J = 0, KVEC%POLY_ORDER
				INDX = BSFUN%INIT + J
				IF (INDX>=0) THEN
					WCPTSUM = WCPTSUM + (BSFUN%N(J)*CTL%WGTS(INDX,0,0))*CTL%PTS(INDX,0,0)
					WSUM = WSUM + BSFUN%N(J)*CTL%WGTS(INDX,0,0)
				ENDIF
			ENDDO
			GET_POINT_NURVE_CURVE_2D = (1.0D0/WSUM) * WCPTSUM
		ELSE
			PRINT *, '[ERROR]  GIVEN SET OF CONTROL POINTS IS NOT VALID !'
		ENDIF

	END FUNCTION GET_POINT_NURVE_CURVE_2D


	!!  FIND DERIVATIVES OF NURBS CURVE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : A POINT ON THE NURBS CURVE
	SUBROUTINE GET_DIFF_NURVE_CURVE_2D(DIFF_NURBS,PT,KVEC,CTL,DIFF_ORDER)

		TYPE(FUNCTION_1D), INTENT(OUT) :: DIFF_NURBS(2)
		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL
		INTEGER, INTENT(IN) :: DIFF_ORDER

		TYPE(DIFF_BSPLINES) :: DBSFUN
		TYPE(POINT2D) :: DWCPTSUM(0:MAX_DIFF_ORDER)
		REAL(8) :: DWSUM(0:MAX_DIFF_ORDER)
		INTEGER :: INDX
		INTEGER :: I, J, K

		IF (CTL%D==1) THEN
			DBSFUN =  GET_ALL_DIFF_BSPLINES(PT,KVEC,DIFF_ORDER)
			DO K = 0, DIFF_ORDER
				DWCPTSUM(K) = POINT2D(0.0D0,0.0D0)
				DWSUM(K) = 0.0D0
				DO J = 0, KVEC%POLY_ORDER
					INDX = DBSFUN%INIT + J
					IF (INDX>=0) THEN
						DWCPTSUM(K) = DWCPTSUM(K) + (DBSFUN%N(J,K)*CTL%WGTS(INDX,0,0))*CTL%PTS(INDX,0,0)
						DWSUM(K) = DWSUM(K) + DBSFUN%N(J,K)*CTL%WGTS(INDX,0,0)
					ENDIF
				ENDDO
			ENDDO
			DO K = 0, DIFF_ORDER
				DIFF_NURBS(1)%VAL(K) = DWCPTSUM(K)%X
				DIFF_NURBS(2)%VAL(K) = DWCPTSUM(K)%Y
				DO J = 1, K
					DIFF_NURBS(1)%VAL(K) = DIFF_NURBS(1)%VAL(K) - BINOM(K,J)*DWSUM(J)*DIFF_NURBS(1)%VAL(K-J)
					DIFF_NURBS(2)%VAL(K) = DIFF_NURBS(2)%VAL(K) - BINOM(K,J)*DWSUM(J)*DIFF_NURBS(2)%VAL(K-J)
				ENDDO
				DIFF_NURBS(1)%VAL(K) = DIFF_NURBS(1)%VAL(K) / DWSUM(0)
				DIFF_NURBS(2)%VAL(K) = DIFF_NURBS(2)%VAL(K) / DWSUM(0)
			ENDDO
		ELSE
			PRINT *, '[ERROR]  GIVEN SET OF CONTROL POINTS IS NOT VALID !'
		ENDIF

	END SUBROUTINE GET_DIFF_NURVE_CURVE_2D


	!!  FIND A POINT ON NURBS SURFACE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT ON TWO-DIMENSIONAL SPACE, KVEC - A VALID KNOT VECTOR ARRAY(2)
	!!  OUTPUT : A POINT ON THE NURBS SURFACE
	TYPE(POINT2D) FUNCTION GET_POINT_NURVE_SURFACE_2D(PT,KVEC,CTL)

		TYPE(POINT2D), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC(2)
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL

		TYPE(BSPLINES) :: BSFUN(2)
		TYPE(POINT2D) :: WCPTSUM
		REAL(8) :: WSUM
		INTEGER :: INDX(2)
		INTEGER :: J1, J2

		IF (CTL%D==2) THEN
			BSFUN(1) =  GET_ALL_BSPLINES(PT%X,KVEC(1))
			BSFUN(2) =  GET_ALL_BSPLINES(PT%Y,KVEC(2))
			WCPTSUM = POINT2D(0.0D0,0.0D0)
			WSUM = 0.0D0
			DO J1 = 0, KVEC(1)%POLY_ORDER
			DO J2 = 0, KVEC(2)%POLY_ORDER
				INDX(1) = BSFUN(1)%INIT + J1
				INDX(2) = BSFUN(2)%INIT + J2
				IF (INDX(1)>=0 .AND. INDX(2)>=0) THEN
					WCPTSUM = WCPTSUM + (BSFUN(1)%N(J1)*BSFUN(2)%N(J2)*CTL%WGTS(INDX(1),INDX(2),0))*CTL%PTS(INDX(1),INDX(2),0)
					WSUM = WSUM + BSFUN(1)%N(J1)*BSFUN(2)%N(J2)*CTL%WGTS(INDX(1),INDX(2),0)
				ENDIF
			ENDDO
			ENDDO
			GET_POINT_NURVE_SURFACE_2D = (1.0D0/WSUM) * WCPTSUM
		ELSE
			PRINT *, '[ERROR]  GIVEN SET OF CONTROL POINTS IS NOT VALID !'
		ENDIF

	END FUNCTION GET_POINT_NURVE_SURFACE_2D


	!!  FIND DERIVATIVES OF NURBS SURFACE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : DERIVATIVES OF NURBS SURFACE
	SUBROUTINE GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,PT,KVEC,CTL,DIFF_ORDER)

		TYPE(FUNCTION_2D), INTENT(OUT) :: DIFF_NURBS(2)
		TYPE(POINT2D), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC(2)
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL
		INTEGER, INTENT(IN) :: DIFF_ORDER

		TYPE(DIFF_BSPLINES) :: DBSFUN(2)
		TYPE(POINT2D) :: DWCPTSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
		REAL(8) :: DWSUM(0:MAX_DIFF_ORDER,0:MAX_DIFF_ORDER)
		INTEGER :: INDX(2)
		INTEGER :: I, J, K, L, J1, J2

		IF (CTL%D==2) THEN
			DBSFUN(1) =  GET_ALL_DIFF_BSPLINES(PT%X,KVEC(1),DIFF_ORDER)
			DBSFUN(2) =  GET_ALL_DIFF_BSPLINES(PT%Y,KVEC(2),DIFF_ORDER)
			DO K = 0, DIFF_ORDER
			DO L = 0, DIFF_ORDER-K
				DWCPTSUM(K,L) = POINT2D(0.0D0,0.0D0)
				DWSUM(K,L) = 0.0D0
				DO J1 = 0, KVEC(1)%POLY_ORDER
					INDX(1) = DBSFUN(1)%INIT + J1
					IF (INDX(1)>=0) THEN
						DO J2 = 0, KVEC(2)%POLY_ORDER
							INDX(2) = DBSFUN(2)%INIT + J2
							IF (INDX(2)>=0 .AND. DABS(CTL%WGTS(INDX(1),INDX(2),0))>EPS) THEN
								DWCPTSUM(K,L) = DWCPTSUM(K,L) + (DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*CTL%WGTS(INDX(1),INDX(2),0))*CTL%PTS(INDX(1),INDX(2),0)
								DWSUM(K,L) = DWSUM(K,L) + DBSFUN(1)%N(J1,K)*DBSFUN(2)%N(J2,L)*CTL%WGTS(INDX(1),INDX(2),0)
							ENDIF
						ENDDO
					ENDIF
				ENDDO
			ENDDO
			ENDDO
			DO K = 0, DIFF_ORDER
			DO L = 0, DIFF_ORDER-K
				DIFF_NURBS(1)%VAL(K,L) = DWCPTSUM(K,L)%X
				DIFF_NURBS(2)%VAL(K,L) = DWCPTSUM(K,L)%Y
				DO J1 = 1, K
					DIFF_NURBS(1)%VAL(K,L) = DIFF_NURBS(1)%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS(1)%VAL(K-J1,L)
					DIFF_NURBS(2)%VAL(K,L) = DIFF_NURBS(2)%VAL(K,L) - BINOM(K,J1)*DWSUM(J1,0)*DIFF_NURBS(2)%VAL(K-J1,L)
				ENDDO
				DO J2 = 1, L
					DIFF_NURBS(1)%VAL(K,L) = DIFF_NURBS(1)%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS(1)%VAL(K,L-J2)
					DIFF_NURBS(2)%VAL(K,L) = DIFF_NURBS(2)%VAL(K,L) - BINOM(L,J2)*DWSUM(0,J2)*DIFF_NURBS(2)%VAL(K,L-J2)
				ENDDO
				DO J1 = 1, K
				DO J2 = 1, L
					DIFF_NURBS(1)%VAL(K,L) = DIFF_NURBS(1)%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS(1)%VAL(K-J1,L-J2)
					DIFF_NURBS(2)%VAL(K,L) = DIFF_NURBS(2)%VAL(K,L) - BINOM(K,J1)*BINOM(L,J2)*DWSUM(J1,J2)*DIFF_NURBS(2)%VAL(K-J1,L-J2)
				ENDDO
				ENDDO
				DIFF_NURBS(1)%VAL(K,L) = DIFF_NURBS(1)%VAL(K,L) / DWSUM(0,0)
				DIFF_NURBS(2)%VAL(K,L) = DIFF_NURBS(2)%VAL(K,L) / DWSUM(0,0)
			ENDDO
			ENDDO
		ELSE
			PRINT *, '[ERROR]  GIVEN SET OF CONTROL POINTS IS NOT VALID !'
		ENDIF

	END SUBROUTINE GET_DIFF_NURVE_SURFACE_2D


	!!  FIND DERIVATIVES OF NURBS SURFACE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : DERIVATIVES OF NURBS SURFACE
	SUBROUTINE GET_DIFF_EXOTIC_GEO_MAP(DIFF_NURBS,PT,KVEC,CTL,DIFF_ORDER)

		TYPE(FUNCTION_2D), INTENT(OUT) :: DIFF_NURBS(2)
		TYPE(POINT2D), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC(2)
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL
		INTEGER, INTENT(IN) :: DIFF_ORDER

		TYPE(DIFF_BSPLINES) :: DBSFUN
		TYPE(POINT2D) :: DWCPTSUM(0:MAX_DIFF_ORDER)
		REAL(8) :: DWSUM(0:MAX_DIFF_ORDER)
		INTEGER :: INDX
		INTEGER :: I, J, K, L, J1, J2

		IF (CTL%D==2) THEN
! 			PRINT*, 'PT', PT
			DBSFUN =  GET_ALL_DIFF_BSPLINES(PT%X,KVEC(1),DIFF_ORDER)
			DO K = 0, DIFF_ORDER
				DWCPTSUM(K) = POINT2D(0.0D0,0.0D0)
				DWSUM(K) = 0.0D0
				DO J1 = 0, KVEC(1)%POLY_ORDER
					INDX = DBSFUN%INIT + J1
					IF (INDX>=0) THEN
! 						PRINT*, 'DBSFUN',J1,K, DBSFUN%N(J1,K)
						DWCPTSUM(K) = DWCPTSUM(K) + (DBSFUN%N(J1,K)*CTL%WGTS(INDX,2,0))*CTL%PTS(INDX,2,0)
						DWSUM(K) = DWSUM(K) + DBSFUN%N(J1,K)*CTL%WGTS(INDX,2,0)
					ENDIF
				ENDDO
			ENDDO

			
			DIFF_NURBS(1)%VAL(0,0) = PT%Y**2*DWCPTSUM(0)%X/DWSUM(0)
			DIFF_NURBS(2)%VAL(0,0) = PT%Y**2*DWCPTSUM(0)%Y/DWSUM(0)
			
			DIFF_NURBS(1)%VAL(1,0) = PT%Y**2*((DWCPTSUM(1)%X/DWSUM(0)) - (DWCPTSUM(0)%X*DWSUM(1)/DWSUM(0)**2))
			DIFF_NURBS(2)%VAL(1,0) = PT%Y**2*((DWCPTSUM(1)%Y/DWSUM(0)) - (DWCPTSUM(0)%Y*DWSUM(1)/DWSUM(0)**2))
			
			DIFF_NURBS(1)%VAL(0,1) = 2.D0*PT%Y*DWCPTSUM(0)%X/DWSUM(0)
			DIFF_NURBS(2)%VAL(0,1) = 2.D0*PT%Y*DWCPTSUM(0)%Y/DWSUM(0)

		ELSE
			PRINT *, '[ERROR]  GIVEN SET OF CONTROL POINTS IS NOT VALID !'
		ENDIF
		
! 		PRINT*, DIFF_NURBS(1)%VAL(1,0)*DIFF_NURBS(2)%VAL(0,1)-DIFF_NURBS(1)%VAL(0,1)*DIFF_NURBS(2)%VAL(1,0)
		
	END SUBROUTINE GET_DIFF_EXOTIC_GEO_MAP


	!!  FIND DERIVATIVES OF NURBS CURVE ON TWO-DIMENSIONAL SPACE
	!!  INPUT  : PT - POINT, KVEC - A VALID KNOT VECTOR, DIFF_ORDER - ORDER OF DIFFERENTIATION
	!!  OUTPUT : A POINT ON THE NURBS CURVE
	TYPE(DIFF_BSPLINES) FUNCTION GET_ALL_DIFF_NURBS_CURVE_2D(PT,KVEC,CTL,DIFF_ORDER)

		REAL(8), INTENT(IN) :: PT
		TYPE(KNOT_VECTOR), INTENT(IN) :: KVEC
		TYPE(CONTROL_POINTS_2D), INTENT(IN) :: CTL
		INTEGER, INTENT(IN) :: DIFF_ORDER

		TYPE(DIFF_BSPLINES) :: DBSFUN
		REAL(8) :: DWSUM(0:MAX_DIFF_ORDER), DWCPTSUM(0:MAX_DIFF_ORDER)
		INTEGER :: INDX
		INTEGER :: I, J, K

		! FIND ALL NON-ZERO B-SPLINES N(XI)
		DBSFUN =  GET_ALL_DIFF_BSPLINES(PT,KVEC,DIFF_ORDER)
		
		! COMPUTE THE WEIGHT FUNCTION W(XI)
		DO K = 0, DIFF_ORDER
			DWSUM(K) = 0.0D0
			DO J = 0, KVEC%POLY_ORDER
				INDX = DBSFUN%INIT + J
				IF (INDX>=0) THEN
					DWSUM(K) = DWSUM(K) + DBSFUN%N(J,K)*CTL%WGTS(INDX,0,0)
				ENDIF
			ENDDO
		ENDDO
				
		DO J = 0, KVEC%POLY_ORDER
			INDX = DBSFUN%INIT + J
			DO K = 0, DIFF_ORDER
				DBSFUN%N(J,K) = DBSFUN%N(J,K)*CTL%WGTS(INDX,0,0)
				DO I = 1, K
					DBSFUN%N(J,K) = DBSFUN%N(J,K) - BINOM(K,I)*DWSUM(I)*DBSFUN%N(J,K-I)
				ENDDO
				DBSFUN%N(J,K) = DBSFUN%N(J,K) / DWSUM(0)
			ENDDO
		ENDDO

	GET_ALL_DIFF_NURBS_CURVE_2D = DBSFUN
	
	END FUNCTION GET_ALL_DIFF_NURBS_CURVE_2D
	
END MODULE NURBS
